from django.shortcuts import render, redirect
from django.shortcuts import get_object_or_404
from django.contrib import messages
from django.conf import settings
from django.http import HttpResponse
from django.db.models import Count
from datetime import datetime
from collections import OrderedDict
import os
import pandas as pd
from docxtpl import DocxTemplate, InlineImage, RichText, Subdoc
import logging
import base64
from io import BytesIO
from PIL import Image
import re
from docx.shared import Mm
import openpyxl
import markdown2
from bs4 import BeautifulSoup
from docx.shared import Inches
import markdown
from martor.utils import LazyEncoder
from datetime import datetime, date
import pytz

#upload file evidence
import uuid
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from xlsxwriter.utility import xl_rowcol_to_cell


from .forms import  PentestTaskForm, VulnerabilityForm, AffectedURLForm, AffectedURLFormSet, VulnTemplateForm
from .models import PentestTask, Vulnerability, AffectedURL, ExportLog, VulnTemplate, Notification
from appsec_task.models import AppSecTask
from appsec_task.views import sync_status
from task_manager.decorators import require_groups

from django.forms import inlineformset_factory
from django.forms.models import model_to_dict
from django.core.exceptions import PermissionDenied
from django.utils import timezone
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User

# Martor
from task_manager.settings import MAX_IMAGE_UPLOAD_SIZE, MARTOR_UPLOAD_PATH, MEDIA_URL, MEDIA_ROOT, TEMPLATES_ROOT, REPORTS_MEDIA_ROOT, SERVER_CONF, TEMPLATES_DIRECTORIES, MARTOR_MEDIA_URL
# PeTeReport config for Martor
from pentest_task.petereport_config import PETEREPORT_MARKDOWN, PETEREPORT_TEMPLATES, DEFECTDOJO_CONFIG, PETEREPORT_CONFIG


# from . import export_report
logger = logging.getLogger(__name__)


status_colors = {
        "Not Started": "bg-info",
        "In Progress": "bg-warning text-dark",
        "Reported": "bg-primary",
        "Retest": "bg-danger",
        "Interrupt": "bg-danger text-dark",
        "Done": "bg-success",
        "Cancel": "bg-danger text-dark",
    }

def safe_str(value):
    return "" if pd.isna(value) or value is None else str(value).strip()

def safe_int(value):
    try:
        return int(value) if not pd.isna(value) and str(value).strip().isdigit() else None
    except ValueError:
        return None

def safe_date(request, val):
    try:
        if pd.isna(val):
            return None
        if isinstance(val, (datetime, date, pd.Timestamp)):
            return val.date() if isinstance(val, pd.Timestamp) else val
        return pd.to_datetime(str(val)).date()
    except Exception as e:
        # print(f"âŒ safe_date error: {e}, val: {val}")
        messages.error(request,f"âŒ safe_date error: {e}, val: {val}")
        return None


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def get_notifications(request):
    # Láº¥y táº¥t cáº£ thÃ´ng bÃ¡o chÆ°a Ä‘á»c cá»§a ngÆ°á»i dÃ¹ng
    notifications = Notification.objects.filter(user=request.user).order_by('-created_at')
    unread_notis = Notification.objects.filter(user=request.user, is_read=False)
    
    # Táº¡o danh sÃ¡ch thÃ´ng bÃ¡o cho response
    notif_list = []
    for notif in notifications:
        notif_list.append({
            'id': notif.id,
            'title': notif.title,
            'description': notif.description,
            'created_at': notif.created_at.strftime('%d/%m/%Y %H:%M:%S'),  # Gá»­i giá» UTC cho created_at
            'created_at_vn': notif.created_at_vn,  # Gá»­i giá» theo GMT+7 cho created_at_vn
            'url': notif.url,
            'is_read': notif.is_read,
        })
    
    # Tráº£ vá» thÃ´ng bÃ¡o dáº¡ng JSON
    return JsonResponse({'notifications': notif_list, 'notis_count': len(notif_list), 'unread_notis_count': len(unread_notis) })


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def mark_notification_as_read(request, notif_id):
    # Láº¥y thÃ´ng bÃ¡o tá»« ID
    notification = get_object_or_404(Notification, id=notif_id, user=request.user)
    notification.is_read = True
    notification.save()
    return JsonResponse({'status': 'success'})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_pentest_tasks(request):
    tasks = PentestTask.objects.all()
    return render(request, 'pentest_task/list_pentest_tasks.html', {'tasks': tasks, "status_colors":status_colors})


@login_required
@require_groups(['Pentester', 'Leader'])
def create_pentest_task(request, appsec_task_id):
    appsec_task = get_object_or_404(AppSecTask, id=appsec_task_id)

    if request.method == "POST":
        form = PentestTaskForm(request.POST)
        if form.is_valid():
            pentest_task = form.save(commit=False)

            # FIX QUAN TRá»ŒNG: gÃ¡n AppSecTask Ä‘Ãºng
            pentest_task.appsec_task = appsec_task
            pentest_task.name=appsec_task.name
            #  sync status vá»›i appsec_task
            sync_status(appsec_task.id)
            pentest_task.save()

            # Gá»­i noti náº¿u cÃ³ ngÆ°á»i Ä‘Æ°á»£c assign
            if pentest_task.PIC_ISM:
                try:
                    user_assignee = User.objects.get(username=new_assignee)
                    Notification.objects.create(
                        user=user_assignee,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{task.id}", 
                       
                    )
                except User.DoesNotExist:
                    pass  

            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(initial={"name": appsec_task.name, "description": appsec_task.description})  # GÃ¡n trÆ°á»›c vÃ o form
        
    return render(request, "pentest_task/create_pentest_task.html", {"form": form, "appsec_task": appsec_task})


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)
    old_assignee = task.PIC_ISM

    appsec_task = task.appsec_task  # Láº¥y AppSecTask liÃªn káº¿t
    if request.method == "POST":
        form = PentestTaskForm(request.POST, instance=task)
        if form.is_valid():
            pentest_task = form.save(commit=False)
            pentest_task.appsec_task = appsec_task 
            sync_status(appsec_task.id)
            pentest_task.save()

            new_assignee = pentest_task.PIC_ISM
            if new_assignee != old_assignee and new_assignee:
                try:
                    user_assignee = User.objects.get(username=new_assignee)
                    Notification.objects.create(
                        user=user_assignee,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{task.id}", 
                       
                    )
                except User.DoesNotExist:
                    pass

            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(instance=task, initial={"name": appsec_task.name, "description": appsec_task.description})  # GÃ¡n trÆ°á»›c vÃ o form


    return render(request, "pentest_task/edit_pentest_task.html", {"form": form, "task": task, "appsec_task": appsec_task})


@login_required
@require_groups(['Pentester', 'Leader'])
def view_pentest_task(request, task_id):
    pentest_task = get_object_or_404(PentestTask, id=task_id)
    appsec_task = pentest_task.appsec_task  # Láº¥y AppSecTask liÃªn káº¿t
    
    form = PentestTaskForm(instance=pentest_task)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('risk_rating')  # Sáº¯p xáº¿p tá»« Critical â†’ Low
    context = {
        "form": pentest_task,
        "vulnerabilities": vulnerabilities,
        "appsec_task": appsec_task,
    }
    return render(request, "pentest_task/view_pentest_task.html", context)
 

@login_required
@require_groups(['Pentester', 'Leader'])
def delete_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)

    if request.method == "POST":
        logger.info(f"Task Deleted: {task}")  # Ghi log xÃ³a task
        task.delete()
    
    return redirect('pentest_task:list_pentest_tasks')  # Quay láº¡i danh sÃ¡ch ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def create_retest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id, status="Reported")  # Láº¥y task gá»‘c

    if request.method == "POST":
        start_retest = request.POST.get("start_retest") or None
        end_retest = request.POST.get("end_retest") or None
            
        if start_retest and end_retest and start_retest > end_retest:
            messages.error(request, "Start Retest date must be before or equal to End Retest date.")
        if messages.get_messages(request):
            return render(request, "pentest_task/create_retest_task.html",{'task':task})
    
        else:
            task.status="Retest"
            task.PIC_ISM=request.POST.get("PIC_ISM")
            task.start_retest=start_retest
            task.end_retest=end_retest

            task.save()
            messages.success(request, "Retest Task created successfully!")
            return redirect('pentest_task:list_pentest_tasks')
    
    return render(request, "pentest_task/create_retest_task.html", {"task": task})


@login_required
@require_groups(['Pentester', 'Leader'])
def list_retest_tasks(request):
    retest_tasks = PentestTask.objects.filter(status="Retest")  # Lá»c cÃ¡c task cÃ³ status "Retest"
    
    return render(request, "pentest_task/list_retest_tasks.html", {
        "tasks": retest_tasks,
        "status_colors": status_colors
    })


@login_required 
@require_groups(['Pentester', 'Leader'])
def get_vuln_template_suggestions(request):
    query = request.GET.get('query', '')  # Nháº­n chuá»—i tÃ¬m kiáº¿m tá»« ngÆ°á»i dÃ¹ng
    templates = VulnTemplate.objects.filter(name_vuln__icontains=query)  # TÃ¬m kiáº¿m theo tÃªn lá»— há»•ng
    results = [{'id': tmpl.id, 
                'name_vuln': tmpl.name_vuln, 
                'risk_score': tmpl.risk_score,  # Tráº£ vá» description
                'risk_vector': tmpl.risk_vector,             # Tráº£ vá» impact
                'risk_rating': tmpl.risk_rating,  # Tráº£ vá» recommendation
                'description': tmpl.description, 
                'likelihood_rate': tmpl.likelihood_rate,  # Tráº£ vá» description
                'risk_av': tmpl.risk_av,             # Tráº£ vá» impact
                'risk_ac': tmpl.risk_ac, # Tráº£ vá» recommendation
                'risk_pr': tmpl.risk_pr, 
                'risk_ui': tmpl.risk_ui,  # Tráº£ vá» description
                'impact_rate': tmpl.impact_rate,             # Tráº£ vá» impact
                'impact': tmpl.impact,# Tráº£ vá» recommendation
                'recommendation': tmpl.recommendation, 
                'reference': tmpl.reference,  # Tráº£ vá» description
                }
               for tmpl in templates]  # Láº¥y danh sÃ¡ch káº¿t quáº£
    return JsonResponse({'results': results})  # Tráº£ vá» káº¿t quáº£ dÆ°á»›i dáº¡ng JSON


@login_required
@require_groups(['Pentester', 'Leader'])
def add_vulnerability(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST)
        if form.is_valid():
            vulnerability = form.save(commit=False)

            # ğŸŸ¢ Láº¥y vÃ  lÆ°u cÃ¡c giÃ¡ trá»‹ CVSS
            # vulnerability.risk_score = request.POST.get("risk_score", "").strip()
            # vulnerability.risk_rating = request.POST.get("risk_rating", "").strip()
            # vulnerability.risk_vector = request.POST.get("risk_vector", "").strip()
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)

            # ğŸŸ¢ Láº¥y giÃ¡ trá»‹ AV, AC, PR, UI tá»« request hoáº·c giá»¯ nguyÃªn giÃ¡ trá»‹ cÅ©
            av_value = request.POST.get("risk_av", "").strip() or vulnerability.risk_av
            ac_value = request.POST.get("risk_ac", "").strip() or vulnerability.risk_ac
            pr_value = request.POST.get("risk_pr", "").strip() or vulnerability.risk_pr
            ui_value = request.POST.get("risk_ui", "").strip() or vulnerability.risk_ui

            # ğŸŸ¢ Mapping giÃ¡ trá»‹ thÃ nh dáº¡ng thÃ¢n thiá»‡n
            av_mapping = {"N": "Network", "A": "Adjacent", "L": "Local", "P": "Physical"}
            ac_mapping = {"L": "Low", "H": "High"}
            pr_mapping = {"N": "None", "L": "Low", "H": "High"}
            ui_mapping = {"N": "None", "R": "Required"}

            # ğŸŸ¢ GÃ¡n giÃ¡ trá»‹ Ä‘Ã£ Ä‘Æ°á»£c mapping (náº¿u cÃ³)
            vulnerability.risk_av = av_mapping.get(av_value, vulnerability.risk_av)
            vulnerability.risk_ac = ac_mapping.get(ac_value, vulnerability.risk_ac)
            vulnerability.risk_pr = pr_mapping.get(pr_value, vulnerability.risk_pr)
            vulnerability.risk_ui = ui_mapping.get(ui_value, vulnerability.risk_ui)

            # ğŸŸ¢ LiÃªn káº¿t vá»›i PentestTask vÃ  lÆ°u vÃ o DB
            vulnerability.pentest_task = pentest_task
            vulnerability.save()

            # return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            # formset
            formset = AffectedURLFormSet(request.POST, instance=vulnerability)
            if formset.is_valid():
                formset.save()
                return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            else:
                messages.error(request, f"âŒ Lá»—i khi lÆ°u11: {form.errors} | Formset: {formset.errors}")
                # return redirect('list_pentest_tasks')
        else:
            # messages.error(request, f"âŒ Lá»—i khi lÆ°u: {form.errors} | Formset: {formset.errors}")
            formset = AffectedURLFormSet(request.POST)
    else:
        form = VulnerabilityForm()
        formset = AffectedURLFormSet()


    # TÃ¬m kiáº¿m VulnTemplate
    search_query = request.GET.get('search', '')
    vuln_templates = VulnTemplate.objects.filter(name_vuln__icontains=search_query)

    return render(request, "pentest_task/add_vulnerability.html", {
        "form": form,
        'formset': formset,
        "pentest_task": pentest_task,
        'vuln_templates': vuln_templates,
    })


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST, instance=vulnerability)
        formset = AffectedURLFormSet(request.POST, instance=vulnerability)

        if form.is_valid() and formset.is_valid():
            vulnerability = form.save(commit=False)

            # LÆ°u formset, bá» qua cÃ¡c form rá»—ng khÃ´ng cÃ³ dá»¯ liá»‡u
            instances = formset.save(commit=False)
            for instance in instances:
                # Bá» qua form rá»—ng khÃ´ng cÃ³ dá»¯ liá»‡u
                if not any([instance.vuln_api, instance.request, instance.response, instance.note, instance.poc]):
                    continue
                instance.vulnerability = vulnerability
                instance.save()

            # XÃ³a cÃ¡c dÃ²ng Ä‘Ã£ Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u DELETE
            for obj in formset.deleted_objects:
                obj.delete()

            # Cáº­p nháº­t thá»§ cÃ´ng cÃ¡c trÆ°á»ng CVSS
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)
            vulnerability.risk_av = request.POST.get("risk_av", vulnerability.risk_av)
            vulnerability.risk_ac = request.POST.get("risk_ac", vulnerability.risk_ac)
            vulnerability.risk_pr = request.POST.get("risk_pr", vulnerability.risk_pr)
            vulnerability.risk_ui = request.POST.get("risk_ui", vulnerability.risk_ui)
            vulnerability.save()

            return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
        # else:
        #     messages.error(request, f"âŒ Lá»—i khi lÆ°u: {form.errors} | Formset: {formset.errors}")
    else:
        form = VulnerabilityForm(instance=vulnerability)
        formset = AffectedURLFormSet(instance=vulnerability)
      
    return render(request, "pentest_task/edit_vulnerability.html", {
        "form": form,
        "formset": formset,
        "pentest_task": pentest_task,
        "vulnerability": vulnerability,
        "empty_form": formset.empty_form,
    })


def risk_summary_data(pentest_task_id):
    # GiÃ¡ trá»‹ máº·c Ä‘á»‹nh Ä‘á»ƒ trÃ¡nh lá»—i 'referenced before assignment'
    risk_summary = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    risk_summary_api = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    # 1. Äáº¿m sá»‘ lÆ°á»£ng Vulnerability theo risk_rating
    risk_counts = (
        Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
        .values("risk_rating")
        .annotate(total=Count("id"))
    )

    for item in risk_counts:
        rating = item["risk_rating"]
        if rating in risk_summary:
            risk_summary[rating] = item["total"]

    # 2. Äáº¿m sá»‘ lÆ°á»£ng affected URL theo tá»«ng má»©c Ä‘á»™ rá»§i ro
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
    for vuln in vulnerabilities:
        url_count = AffectedURL.objects.filter(vulnerability=vuln).count()
        if vuln.risk_rating in risk_summary_api:
            risk_summary_api[vuln.risk_rating] += url_count

    return risk_summary, risk_summary_api


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def list_vulnerabilities(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerabilities = pentest_task.vulnerabilities.all()
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')  # Sáº¯p xáº¿p tá»« Critical â†’ Low
    risk_summary,risk_summary_api = risk_summary_data(pentest_task_id)
    sum(risk_summary.values())
    # ğŸ”¢ GÃ¡n Ref ID theo thá»© tá»± risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        expected_ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # Náº¿u ref khÃ¡c thÃ¬ má»›i cáº­p nháº­t vÃ  save
        if vuln.ref != expected_ref:
            vuln.ref = expected_ref
            vuln.save(update_fields=["ref"])  # âœ… Chá»‰ lÆ°u field ref
        vuln.api_count= AffectedURL.objects.filter(vulnerability=vuln).count()
        # vuln.affected_url_list = vuln.affected_url.split("\n") if vuln.affected_url else []  # Táº¡o danh sÃ¡ch URL
        # vuln.api_count = len(vuln.affected_url_list)  # Äáº¿m sá»‘ lÆ°á»£ng API nhÆ°ng **khÃ´ng lÆ°u vÃ o DB**

    export_logs = ExportLog.objects.filter(pentest_task=pentest_task).order_by('-export_time')
    # Chuyá»ƒn Ä‘á»•i export_time sang GMT+7
    bangkok = pytz.timezone('Asia/Bangkok')
    for log in export_logs:
        if log.export_time:
            log.export_time_vn = log.export_time.astimezone(bangkok).strftime('%d/%m/%Y %H:%M:%S')
        else:
            log.export_time_vn = None


    return render(request, "pentest_task/list_vulnerabilities.html", {
        "pentest_task": pentest_task,
        "vulnerabilities": vulnerabilities,
        "risk_summary": risk_summary,
        "risk_summary_api": risk_summary_api,
        "export_logs": export_logs,
    })


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def view_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    # Kiá»ƒm tra vulnerability thuá»™c pentest_task
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    if vulnerability.pentest_task.id != pentest_task_id:
        raise PermissionDenied("Vulnerability khÃ´ng thuá»™c vá» Pentest Task nÃ y.")

    # Láº¥y danh sÃ¡ch affected_urls cá»§a vulnerability Ä‘Ã³
    affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)

    # Kiá»ƒm tra tá»«ng AffectedURL (phÃ²ng khi cÃ³ dá»¯ liá»‡u bá»‹ nháº­p nháº§m DB)
    for url in affected_urls:
        if url.vulnerability_id != vulnerability.id:
            raise PermissionDenied("AffectedURL khÃ´ng khá»›p vá»›i vulnerability.")


    # pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    # # Láº¥y danh sÃ¡ch affected_urls tá»« vulnerability
    # affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)
    return render(request, "pentest_task/view_vulnerability.html", {"form": vulnerability, "pentest_task": pentest_task, "affected_urls": affected_urls})


@login_required
@require_groups(['Pentester', 'Leader'])
def delete_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)
    if request.method == "POST":
        messages.success(request, f"Vulnerability {vulnerability.name_vuln} has been deleted successfully.")
        logger.info(f"Vulnerability Deleted: {vulnerability}")  # Ghi log xÃ³a task
        vulnerability.delete()
    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)


@login_required
@require_groups(['Pentester', 'Leader'])
def import_vulnerabilities(request):
    if request.method == "POST" and request.FILES.get("task_file"):
        file = request.FILES["task_file"]
        vulnerabilities = set()
        try:
            xls = pd.ExcelFile(file)

            # Sheet 1: VERIFY TASK
            vuln_df = pd.read_excel(xls, sheet_name="Vulnerability")
            for _, row in vuln_df.iterrows():
                pentest_task_name = safe_str(row.get("name"))
                ref=safe_str(row.get("ref")) #giÃ¡ trá»‹ ref cá»§a vulnerability
                if not pentest_task_name:
                    print("âš ï¸ Bá» qua dÃ²ng vÃ¬ khÃ´ng cÃ³ pentest_task_name:", row.to_dict())
                    continue
                
                ref_prefix = ref.split('-')[0]  # Láº¥y pháº§n trÆ°á»›c dáº¥u "-" Ä‘á»ƒ láº¥y giÃ¡ trá»‹ ref cá»§a pentest_task
                try:
                    pentest_task = PentestTask.objects.get(ref=ref_prefix)
                except PentestTask.DoesNotExist:
                    messages.warning(request, f"KhÃ´ng tÃ¬m tháº¥y PentestTask vá»›i ref: {ref_prefix}")
                    continue

                Vulnerability.objects.create(
                    pentest_task=pentest_task,
                    ref=ref,
                    name_vuln=safe_str(row.get("name_vuln")),
                    risk_rating=safe_str(row.get("risk_rating")),
                    notify_date=safe_date(request,row.get("notify_date")),
                    status=safe_str(row.get("status")),
                )
            

            messages.success(request, "Vulnerability imported successfully")
        except Exception as e:
            messages.error(request, f"âŒ Error in Vuln: {e}, row: {row.to_dict()}")
           
        return redirect("pentest_task:list_pentest_tasks")


def convert_text(text):
    evidence_parts = []

    # KHÃ”NG xoÃ¡ \n trong input â€” giá»¯ nguyÃªn format markdown ngÆ°á»i dÃ¹ng nháº­p
    # html_content = markdown.markdown(text)
    html_content = markdown.markdown(
        text,
        extensions=["fenced_code", "codehilite"]
    )
    soup = BeautifulSoup(html_content, "html.parser")
    image_pattern = re.compile(r'!\[.*?\]\(data:image/.*?;base64,(.*?)\)', re.DOTALL)

    for element in soup.children:
        rt = RichText() 
        rt_code = RichText()
        rt_precode = RichText()
        rt_list = RichText()
        rt_number = RichText()
        if element.name in ["h1", "h2", "h3"]:
            rt.add("\n")
            rt.add(element.text.strip(), bold=True,italic=True, size=37)
            rt.add("\n")
            evidence_parts.append({"type": "text", "content": rt})
            
        elif element.name == "blockquote":
            quote_text = element.get_text(strip=True)
            formatted = "\n> " + quote_text.replace("\n", "\n> ") + "\n"
            rt.add(formatted, italic=True, color="#555555")  
            evidence_parts.append({"type": "text", "content": rt})
        # Handle horizontal rule
        elif element.name == "hr":
            rt.add("-" * 30)
            evidence_parts.append({"type": "text", "content": rt})
           
        elif element.name == "p":
            for child in element.children:
                name = getattr(child, "name", None)
                if name == "strong":
                    rt.add(child.text, bold=True)
                    
                elif name == "em":
                    rt.add(child.text, italic=True)
                    
                elif name in ["h1", "h2", "h3"]:
                    rt.add(element.text.upper(), bold=True,size=23)
                    
                elif name == "code":
                    rt_code.add(child.text.strip(), italic=True, font="Consolas", color="#8B0000")
                    
                elif name is None:
                    rt.add(str(child))
                else:
                    rt.add(str(child))
                    
            evidence_parts.append({"type": "text", "content": rt})
            evidence_parts.append({"type": "code", "content": rt_code})
       
        elif element.name == "pre":
            code = element.find("code")
            code_text = code.get_text() if code else element.get_text()
            rt_precode.add(code_text.strip(), font="Consolas", size=20, color="#555555")
            evidence_parts.append({"type": "precode", "content": rt_precode})

        elif element.name == "ul":
            for li in element.find_all("li", recursive=False):
                rt_list.add(f"â€¢ {li.get_text(strip=True)}\n")
            evidence_parts.append({"type": "list", "content": rt})

        # ==== ORDERED LIST ====
        elif element.name == "ol":
            # rt = RichText()
            for idx, li in enumerate(element.find_all("li", recursive=False), start=1):
                rt_number.add(f"{idx}. {li.get_text(strip=True)}\n")
            evidence_parts.append({"type": "number_list", "content": rt})

        # ==== FALLBACK ====
        else:
            rt.add(element.get_text())
            evidence_parts.append({"type": "text", "content": rt})

    return evidence_parts


def parse_evidence(evidence_md, doc):
    parts = []
    # Báº¯t cáº£ alt_text (caption) vÃ  image_data
    image_pattern = re.compile(r"!\[(.*?)\]\(data:image/.*?;base64,(.*?)\)")
    pos = 0
    rt = RichText()

    for match in image_pattern.finditer(evidence_md):
        start, end = match.span()

        # Pháº§n text trÆ°á»›c áº£nh
        if start > pos:
            text = evidence_md[pos:start].strip()
            if text:
                parts.extend(convert_text(text))

        # Láº¥y caption vÃ  áº£nh
        alt_text = match.group(1)
        image_data = match.group(2)
        image_bytes = base64.b64decode(image_data)
        image_stream = BytesIO(image_bytes)
        image = InlineImage(doc, image_stream, width=Mm(130))
        parts.append({'type': 'image', 'content': image})

        # Caption dÆ°á»›i áº£nh
        caption_rt = RichText()
        caption_rt.add(alt_text.strip(), italic=True, color="#666666")
        parts.append({'type': 'caption', 'content': caption_rt})

        pos = end

    # Pháº§n cÃ²n láº¡i sau áº£nh cuá»‘i
    if pos < len(evidence_md):
        remaining_text = evidence_md[pos:].strip()
        if remaining_text:
            parts.extend(convert_text(remaining_text))

    return parts


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_pentest_report(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    appsec_task = pentest_task.appsec_task
    # Láº¥y danh sÃ¡ch vulnerabilities, sáº¯p xáº¿p theo risk_score (cao -> tháº¥p)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')
    risk_summary,_ = risk_summary_data(pentest_task_id)
    # Ã°ÂŸÂŸÂ¢ Load file Word tá»« template
    template_path = os.path.join(settings.BASE_DIR, "templates", "pentest_template.docx")
    # doc = Document(template_path)

    # Ã°ÂŸÂ“Â‚ Má»Ÿ file template Word
    doc = DocxTemplate(template_path)
    
    # Ã°ÂŸÂ”Â¢ Táº¡o danh sÃ¡ch Ref ID theo thá»© tá»± risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        vuln.save()  # Cáº­p nháº­t ref vÃ o DB
    
    # Ã°ÂŸÂŸÂ¢ Xá»­ lÃ½ dá»¯ liá»‡u thá»i gian & kiá»ƒm tra `None`
    def safe_date(date_value, format_str="%d/%m/%Y"):
        return date_value.strftime(format_str) if date_value else ""

    # Chuyá»ƒn Ä‘á»•i danh sÃ¡ch API tá»« trÆ°á»ng `scope`
    scope_list = pentest_task.scope.splitlines() if pentest_task.scope else []
    scope_table = [{"No": idx + 1, "API": api} for idx, api in enumerate(scope_list)]

    # Äá»‹nh nghÄ©a mÃ u chá»¯ cho tá»«ng má»©c Ä‘á»™ risk rating (dÃ¹ng HEX mÃ u Word)
    risk_text_colors = {
        "Critical": "8B0000",  # Äá» Ä‘áº­m
        "High": "FF0000",      # Äá»
        "Medium": "FFA500",    # Cam
        "Low": "008000",       # Xanh lÃ¡ Ä‘áº­m
        "Recommend": "32CD32"  # Xanh lÃ¡ nháº¡t
    }
    # sáº¯p xáº¿p vuln theo risk_score giáº£m dáº§n    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    placeholder_vulns = []
    for vuln in vulnerabilities:
        color = risk_text_colors.get(vuln.risk_rating, "000000")  # Máº·c Ä‘á»‹nh lÃ  Äen (000000)
        color_likelihood_rate = risk_text_colors.get(vuln.likelihood_rate, "000000")  # Máº·c Ä‘á»‹nh lÃ  Äen (000000)
        color_impact_rate = risk_text_colors.get(vuln.impact_rate, "000000")  # Máº·c Ä‘á»‹nh lÃ  Äen (000000)

        # Láº¥y danh sÃ¡ch affected_url tá»« model má»›i
        affected_url_qs = AffectedURL.objects.filter(vulnerability=vuln)
        affected_url_table = [
            {
                "No": idx + 1,
                "Function": url.function or "",
                "API": url.vuln_api or "",
                "Params": url.params or "",
            }
            for idx, url in enumerate(affected_url_qs)
        ]


        # Format XML Ä‘á»ƒ Word hiá»ƒu mÃ u chá»¯
        risk_rating_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>'
        risk_score_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>'
        risk_likelihood_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_likelihood_rate}"/></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>'
        risk_impact_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_impact_rate}"/></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>'
        placeholder_vulns.append({
                "ref": vuln.ref,
                "name_vuln": vuln.name_vuln,
                "description":vuln.description,
                "risk_score": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>',
                "risk_vector": vuln.risk_vector,
                "risk_rating": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>',
                "likelihood_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.likelihood_rate, "000000")}" /></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>',
                "impact_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.impact_rate, "000000")}" /></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>',
                # "likelihood": vuln.likelihood,
                "risk_av": vuln.risk_av,
                "risk_ac": vuln.risk_ac,
                "risk_pr": vuln.risk_pr,
                "risk_ui": vuln.risk_ui,
                "impact": vuln.impact,
                "evidence_parts": parse_evidence(vuln.evidence, doc),
                "affected_url_table": affected_url_table,
                # "api_count": len(vuln.affected_url.split("\n")) if vuln.affected_url else 0,  # Äáº¿m sá»‘ API
                "recommendation": vuln.recommendation,
                "reference": vuln.reference,
                "status": vuln.status,
            })
   

    placeholders = {
        "task_name": str(pentest_task.name) if pentest_task.name else "",
        "scope": scope_table,
        "today": datetime.today().strftime("%B %d %Y"),  # "March 06 2024"
        "component": str(pentest_task.component) if pentest_task.component else "",
        "start_date": safe_date(pentest_task.start_date, "%B %d %Y"),
        "start_month": safe_date(pentest_task.start_date, "%B"),
        "start_year": str(pentest_task.start_date.year) if pentest_task.start_date else "",
        "end_date": safe_date(pentest_task.end_date, "%B %d %Y"),
        "total_vulnerabilities": str(sum(risk_summary.values())),
        "count_critical": str(risk_summary.get("Critical", 0)),
        "count_high": str(risk_summary.get("High", 0)),
        "count_medium": str(risk_summary.get("Medium", 0)),
        "count_low": str(risk_summary.get("Low", 0)),
        "count_recommend": str(risk_summary.get("Recommend", 0)),
        "environment_prod": str(appsec_task.environment_prod) if appsec_task.environment_prod else "",
        "environment_test": str(pentest_task.environment_test) if pentest_task.environment_test else "",
        "vulnerabilities": placeholder_vulns

    }
        # Truyá»n vÃ o word:    Task Name: {{ task_name }}
        # Component: {{ component }}
        # Start Date: {{ start_date }}
        # {% for vuln in vulnerabilities %} {{vuln.name_vuln}} {% endfor %} 

    # Äiá»n dá»¯ liá»‡u vÃ o template
    doc.render(placeholders)
    # âœ… Ghi log export report
    ExportLog.objects.create(
        pentest_task=pentest_task,
        user=request.user
    )


    # Xuáº¥t file Word vá»›i dá»¯ liá»‡u Ä‘Ã£ thay tháº¿
    response = HttpResponse(content_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
    response["Content-Disposition"] = f'attachment; filename="Pentest_Report_{pentest_task.name}.docx"'
    doc.save(response)

    return response


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_details_vulnerability_excel(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id).prefetch_related('affected_urls')
    # sáº¯p xáº¿p vuln theo risk_score giáº£m dáº§n    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    affected_data = []
    for vuln in vulnerabilities:
        for au in vuln.affected_urls.all():
            affected_data.append({
                "Vuln Name": vuln.name_vuln or "",
                "Ref ID": vuln.ref or "",
                "Risk Rating":vuln.risk_rating or "",
                "Function Name": au.function or "",
                "Vuln API": au.vuln_api or "",
                "Request": au.request or "",
                "Response": au.response or "",
                "Params": au.params or "",
                "Note": au.note or "",
                "POC": au.poc or "",  # POC lÃ  markdown text (cÃ³ thá»ƒ chá»©a áº£nh base64)
            })

    df = pd.DataFrame(affected_data)

    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name="Affected URLs", index=False)
        workbook  = writer.book
        worksheet = writer.sheets["Affected URLs"]

        # Äá»‹nh dáº¡ng kÃ­ch thÆ°á»›c cá»™t vÃ  dÃ²ng
        worksheet.set_column('A:H', 70)  # TÄƒng Ä‘á»™ rá»™ng cÃ¡c cá»™t
        for row in range(1, len(df) + 1):
            worksheet.set_row(row, 170)  # Chiá»u cao dÃ²ng cá»‘ Ä‘á»‹nh

        # Duyá»‡t láº¡i tá»«ng dÃ²ng Ä‘á»ƒ xá»­ lÃ½ POC
        image_pattern = re.compile(r"!\[.*?\]\(data:image/.*?;base64,(.*?)\)")

        for i, poc_md in enumerate(df["POC"]):
            cell_row = i + 1
            text_part = image_pattern.split(poc_md)[0].strip()

            # Ghi pháº§n text cá»§a POC (náº¿u cÃ³)
            if text_part:
                worksheet.write(cell_row, len(df.columns)-1, text_part)

            # ChÃ¨n áº£nh (náº¿u cÃ³)
            for match in image_pattern.finditer(poc_md):
                image_data = match.group(1)
                try:
                    image_bytes = base64.b64decode(image_data)
                    image_stream = BytesIO(image_bytes)

                    # Kiá»ƒm tra há»£p lá»‡
                    img = Image.open(image_stream)
                    img.verify()
                    image_stream.seek(0)

                    worksheet.insert_image(
                        cell_row,
                        len(df.columns)-1,
                        "image.png",
                        {
                            'image_data': image_stream,
                            'x_scale': 1,
                            'y_scale': 1,
                            'positioning': 1,
                        }
                    )
                except Exception as e:
                    print(f"âš ï¸ Lá»—i chÃ¨n áº£nh dÃ²ng {cell_row}: {e}")

    output.seek(0)
    filename = f"details_vuln_of_{pentest_task.name}.xlsx"
    response = HttpResponse(output, content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename={filename}'

    return response


@login_required
@require_groups(['Pentester', 'Leader'])
@csrf_exempt
def martor_upload_image(request):
    try:
        print("ğŸŸ¢ ÄÃ£ gá»i martor_upload_image")
        print("Upload method:", PETEREPORT_MARKDOWN.get("martor_upload_method"))
        print("Upload path:", MARTOR_UPLOAD_PATH)

        if request.method == 'POST' and request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            if 'markdown-image-upload' in request.FILES:
                image = request.FILES['markdown-image-upload']
                print("ğŸ“· ÄÃ£ nháº­n file:", image.name, image.content_type)

                # Kiá»ƒm tra Ä‘á»‹nh dáº¡ng
                image_types = [
                    'image/png', 'image/jpg', 'image/jpeg', 'image/pjpeg', 'image/gif'
                ]
                if image.content_type not in image_types:
                    return JsonResponse({'status': 405, 'error': 'Bad image format.'}, status=405)

                if image.size > MAX_IMAGE_UPLOAD_SIZE:
                    return JsonResponse({
                        'status': 405,
                        'error': f'Maximum image file is {MAX_IMAGE_UPLOAD_SIZE / (1024 * 1024)} MB.'
                    }, status=405)

                if PETEREPORT_MARKDOWN['martor_upload_method'] == 'BASE64':
                    image_content_base64 = base64.b64encode(image.read()).decode('utf-8')
                    image_content_base64_final = f'data:{image.content_type};base64,{image_content_base64}'
                    return JsonResponse({
                        'status': 200,
                        'link': image_content_base64_final,
                        'name': image.name
                    })

                elif PETEREPORT_MARKDOWN['martor_upload_method'] == 'MEDIA':
                    today = datetime.date.today().strftime('%Y/%m/%d/')
                    img_uuid = f"{uuid.uuid4().hex[:32]}-{image.name.replace(' ', '-')}"
                    tmp_path = os.path.join(MARTOR_UPLOAD_PATH, today, img_uuid)

                    print("ğŸ“ LÆ°u file vÃ o:", tmp_path)

                    def_path = default_storage.save(tmp_path, ContentFile(image.read()))
                    img_url = os.path.join(MARTOR_MEDIA_URL, def_path)

                    return JsonResponse({
                        'status': 200,
                        'link': img_url,
                        'name': image.name
                    })

        return JsonResponse({'status': 400, 'error': 'Invalid request!'}, status=400)

    except Exception as e:
        print("âŒ Exception xáº£y ra khi upload:", str(e))
        return JsonResponse({'error': str(e)}, status=500)


#chá»©c nÄƒng táº¡o template
@login_required
@require_groups(['Pentester', 'Leader'])
def save_to_template(request, vuln_id):
    vuln = get_object_or_404(Vulnerability, id=vuln_id)
    
    # Kiá»ƒm tra xem template cÃ³ tá»“n táº¡i chÆ°a
    template, created = VulnTemplate.objects.update_or_create(
        name_vuln=vuln.name_vuln,  # Táº¡o má»›i hoáº·c cáº­p nháº­t náº¿u trÃ¹ng tÃªn
        defaults={
            'risk_score': vuln.risk_score,
            'risk_vector': vuln.risk_vector,
            'risk_rating': vuln.risk_rating,
            'description': vuln.description,
            'likelihood_rate': vuln.likelihood_rate,
            'risk_av': vuln.risk_av,
            'risk_ac': vuln.risk_ac,
            'risk_pr': vuln.risk_pr,
            'risk_ui': vuln.risk_ui,
            'impact_rate': vuln.impact_rate,
            'impact': vuln.impact,
            'recommendation': vuln.recommendation,
            'reference': vuln.reference,
        }
    )

    if created:
        messages.success(request, f"Template '{vuln.name_vuln}' was updated.")
    else:
        messages.info(request, f"Template '{vuln.name_vuln}' was updated.")

    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=vuln.pentest_task_id)


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_vuln_templates(request):
    templates = VulnTemplate.objects.all()
    return render(request, 'pentest_task/list_vuln_templates.html', {'vulnerabilities': templates})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def view_vuln_template(request, vuln_template_id):
    vuln_template = get_object_or_404(VulnTemplate, id=vuln_template_id)
    return render(request, 'pentest_task/view_vuln_template.html', {'form': vuln_template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_create(request):
    form = VulnTemplateForm(request.POST or None)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_edit(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    form = VulnTemplateForm(request.POST or None, instance=template)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form, 'template': template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_delete(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    if request.method == "POST":
        template.delete()
    return redirect('pentest_task:list_vuln_templates')  # Quay láº¡i danh sÃ¡ch ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def my_task_view(request):
    my_tasks = PentestTask.objects.filter(PIC_ISM=request.user)
    return render(request, 'pentest_task/my_tasks.html', {'tasks': my_tasks})


def custom_404_view(request, exception):
    return render(request, "404.html", status=404)

