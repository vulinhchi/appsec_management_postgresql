from django.shortcuts import render, redirect
from django.shortcuts import get_object_or_404
from django.contrib import messages
from django.conf import settings
from django.http import HttpResponse
from django.db.models import Count
from datetime import datetime
from collections import OrderedDict
import os
import pandas as pd
from docxtpl import DocxTemplate, InlineImage, RichText, Subdoc
import logging
import base64
from io import BytesIO
from PIL import Image
import re
from docx.shared import Mm
import openpyxl
import markdown2
from bs4 import BeautifulSoup
from docx.shared import Inches
import markdown
from martor.utils import LazyEncoder
from datetime import datetime, date
import pytz

#upload file evidence
import uuid
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from xlsxwriter.utility import xl_rowcol_to_cell


from .forms import  PentestTaskForm, VulnerabilityForm, AffectedURLForm, AffectedURLFormSet, VulnTemplateForm, TemplateReportForm
from .models import PentestTask, Vulnerability, AffectedURL, ExportLog, VulnTemplate, Notification, TemplateReport, ReportConfig
from appsec_task.models import AppSecTask
from appsec_task.views import sync_status, handle_uploaded_file
from task_manager.decorators import require_groups

from django.forms import inlineformset_factory
from django.forms.models import model_to_dict
from django.core.exceptions import PermissionDenied
from django.utils import timezone
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User

# Martor
from task_manager.settings import MAX_IMAGE_UPLOAD_SIZE, MARTOR_UPLOAD_PATH, MEDIA_URL, MEDIA_ROOT, TEMPLATES_ROOT, REPORTS_MEDIA_ROOT, SERVER_CONF, TEMPLATES_DIRECTORIES, MARTOR_MEDIA_URL
# PeTeReport config for Martor
from pentest_task.petereport_config import PETEREPORT_MARKDOWN, PETEREPORT_TEMPLATES, DEFECTDOJO_CONFIG, PETEREPORT_CONFIG
from django.core.exceptions import ValidationError
from django.http import HttpResponseBadRequest
import magic  # check MIME type


# from . import export_report
logger = logging.getLogger(__name__)


status_colors = {
        "Not Started": "bg-info",
        "In Progress": "bg-warning text-dark",
        "Reported": "bg-primary",
        "Retest": "bg-danger",
        "Interrupt": "bg-danger text-dark",
        "Done": "bg-success",
        "Cancel": "bg-danger text-dark",
    }

def safe_str(value):
    return "" if pd.isna(value) or value is None else str(value).strip()

def safe_int(value):
    try:
        return int(value) if not pd.isna(value) and str(value).strip().isdigit() else None
    except ValueError:
        return None

def safe_date(request, val):
    try:
        if pd.isna(val):
            return None
        if isinstance(val, (datetime, date, pd.Timestamp)):
            return val.date() if isinstance(val, pd.Timestamp) else val
        return pd.to_datetime(str(val)).date()
    except Exception as e:
        # print(f"❌ safe_date error: {e}, val: {val}")
        messages.error(request,f"❌ safe_date error: {e}, val: {val}")
        return None


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def get_notifications(request):
    # Lấy tất cả thông báo chưa đọc của người dùng
    notifications = Notification.objects.filter(user=request.user).order_by('-created_at')
    unread_notis = Notification.objects.filter(user=request.user, is_read=False)
    
    # Tạo danh sách thông báo cho response
    notif_list = []
    for notif in notifications:
        notif_list.append({
            'id': notif.id,
            'title': notif.title,
            'description': notif.description,
            'created_at': notif.created_at.strftime('%d/%m/%Y %H:%M:%S'),  # Gửi giờ UTC cho created_at
            'created_at_vn': notif.created_at_vn,  # Gửi giờ theo GMT+7 cho created_at_vn
            'url': notif.url,
            'is_read': notif.is_read,
        })
    
    # Trả về thông báo dạng JSON
    return JsonResponse({'notifications': notif_list, 'notis_count': len(notif_list), 'unread_notis_count': len(unread_notis) })


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def mark_notification_as_read(request, notif_id):
    # Lấy thông báo từ ID
    notification = get_object_or_404(Notification, id=notif_id, user=request.user)
    notification.is_read = True
    notification.save()
    return JsonResponse({'status': 'success'})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_pentest_tasks(request):
    tasks = PentestTask.objects.all()
    return render(request, 'pentest_task/list_pentest_tasks.html', {'tasks': tasks, "status_colors":status_colors})


@login_required
@require_groups(['Pentester', 'Leader'])
def create_pentest_task(request, appsec_task_id):
    appsec_task = get_object_or_404(AppSecTask, id=appsec_task_id)

    if request.method == "POST":
        form = PentestTaskForm(request.POST)
        if form.is_valid():
            pentest_task = form.save(commit=False)

            # FIX QUAN TRỌNG: gán AppSecTask đúng
            pentest_task.appsec_task = appsec_task
            pentest_task.name=appsec_task.name
            pentest_task.PIC_ISM = form.cleaned_data.get('PIC_ISM', '')

            #  sync status với appsec_task
            sync_status(appsec_task.id)
            pentest_task.save()
            old_assignee = ""
            old_assignees = set([x.strip() for x in old_assignee.split(",") if x.strip()])
            new_assignees = set([x.strip() for x in pentest_task.PIC_ISM.split(",") if x.strip()])

            # Gửi noti cho những người mới được thêm vào
            added_users = new_assignees - old_assignees

            for username in added_users:
                try:
                    user = User.objects.get(username=username)
                    Notification.objects.create(
                        user=user,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{pentest_task.id}",
                    )
                except User.DoesNotExist:
                    continue
    
            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(initial={"name": appsec_task.name, "description": appsec_task.description})  # Gán trước vào form
        
    return render(request, "pentest_task/create_pentest_task.html", {"form": form, "appsec_task": appsec_task,'usernames': form.usernames_json})


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)
    old_assignee = task.PIC_ISM

    appsec_task = task.appsec_task  # Lấy AppSecTask liên kết
    if request.method == "POST":
        form = PentestTaskForm(request.POST, instance=task)
        if form.is_valid():
            pentest_task = form.save(commit=False)
            pentest_task.appsec_task = appsec_task 
            sync_status(appsec_task.id)
            pentest_task.save()

            old_assignees = set([x.strip() for x in old_assignee.split(",") if x.strip()])
            new_assignees = set([x.strip() for x in pentest_task.PIC_ISM.split(",") if x.strip()])

            # Gửi noti cho những người mới được thêm vào
            added_users = new_assignees - old_assignees

            for username in added_users:
                try:
                    user = User.objects.get(username=username)
                    Notification.objects.create(
                        user=user,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{pentest_task.id}",
                    )
                except User.DoesNotExist:
                    continue
            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(instance=task, initial={"name": appsec_task.name, "description": appsec_task.description})  # Gán trước vào form


    return render(request, "pentest_task/edit_pentest_task.html", {"form": form, "task": task, "appsec_task": appsec_task, 'usernames': form.usernames_json})


@login_required
@require_groups(['Pentester', 'Leader'])
def view_pentest_task(request, task_id):
    pentest_task = get_object_or_404(PentestTask, id=task_id)
    appsec_task = pentest_task.appsec_task  # Lấy AppSecTask liên kết
    
    form = PentestTaskForm(instance=pentest_task)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('risk_rating')  # Sắp xếp từ Critical → Low
    context = {
        "form": pentest_task,
        "vulnerabilities": vulnerabilities,
        "appsec_task": appsec_task,
    }
    return render(request, "pentest_task/view_pentest_task.html", context)
 

@login_required
@require_groups(['Pentester', 'Leader'])
def delete_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)

    if request.method == "POST":
        logger.info(f"Task Deleted: {task}")  # Ghi log xóa task
        task.delete()
    
    return redirect('pentest_task:list_pentest_tasks')  # Quay lại danh sách ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def create_retest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id, status="Reported")  # Lấy task gốc

    if request.method == "POST":
        start_retest = request.POST.get("start_retest") or None
        end_retest = request.POST.get("end_retest") or None
            
        if start_retest and end_retest and start_retest > end_retest:
            messages.error(request, "Start Retest date must be before or equal to End Retest date.")
        if messages.get_messages(request):
            return render(request, "pentest_task/create_retest_task.html",{'task':task})
    
        else:
            task.status="Retest"
            task.PIC_ISM=request.POST.get("PIC_ISM")
            task.start_retest=start_retest
            task.end_retest=end_retest

            task.save()
            messages.success(request, "Retest Task created successfully!")
            return redirect('pentest_task:list_pentest_tasks')
    
    return render(request, "pentest_task/create_retest_task.html", {"task": task})


@login_required
@require_groups(['Pentester', 'Leader'])
def list_retest_tasks(request):
    retest_tasks = PentestTask.objects.filter(status="Retest")  # Lọc các task có status "Retest"
    
    return render(request, "pentest_task/list_retest_tasks.html", {
        "tasks": retest_tasks,
        "status_colors": status_colors
    })


@login_required 
@require_groups(['Pentester', 'Leader'])
def get_vuln_template_suggestions(request):
    query = request.GET.get('query', '')  # Nhận chuỗi tìm kiếm từ người dùng
    templates = VulnTemplate.objects.filter(name_vuln__icontains=query)  # Tìm kiếm theo tên lỗ hổng
    results = [{'id': tmpl.id, 
                'name_vuln': tmpl.name_vuln, 
                'risk_score': tmpl.risk_score,  # Trả về description
                'risk_vector': tmpl.risk_vector,             # Trả về impact
                'risk_rating': tmpl.risk_rating,  # Trả về recommendation
                'description': tmpl.description, 
                'likelihood_rate': tmpl.likelihood_rate,  # Trả về description
                'risk_av': tmpl.risk_av,             # Trả về impact
                'risk_ac': tmpl.risk_ac, # Trả về recommendation
                'risk_pr': tmpl.risk_pr, 
                'risk_ui': tmpl.risk_ui,  # Trả về description
                'impact_rate': tmpl.impact_rate,             # Trả về impact
                'impact': tmpl.impact,# Trả về recommendation
                'recommendation': tmpl.recommendation, 
                'reference': tmpl.reference,  # Trả về description
                }
               for tmpl in templates]  # Lấy danh sách kết quả
    return JsonResponse({'results': results})  # Trả về kết quả dưới dạng JSON


@login_required
@require_groups(['Pentester', 'Leader'])
def add_vulnerability(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST)
        if form.is_valid():
            vulnerability = form.save(commit=False)

            # 🟢 Lấy và lưu các giá trị CVSS
            # vulnerability.risk_score = request.POST.get("risk_score", "").strip()
            # vulnerability.risk_rating = request.POST.get("risk_rating", "").strip()
            # vulnerability.risk_vector = request.POST.get("risk_vector", "").strip()
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)

            # 🟢 Lấy giá trị AV, AC, PR, UI từ request hoặc giữ nguyên giá trị cũ
            av_value = request.POST.get("risk_av", "").strip() or vulnerability.risk_av
            ac_value = request.POST.get("risk_ac", "").strip() or vulnerability.risk_ac
            pr_value = request.POST.get("risk_pr", "").strip() or vulnerability.risk_pr
            ui_value = request.POST.get("risk_ui", "").strip() or vulnerability.risk_ui

            # 🟢 Mapping giá trị thành dạng thân thiện
            av_mapping = {"N": "Network", "A": "Adjacent", "L": "Local", "P": "Physical"}
            ac_mapping = {"L": "Low", "H": "High"}
            pr_mapping = {"N": "None", "L": "Low", "H": "High"}
            ui_mapping = {"N": "None", "R": "Required"}

            # 🟢 Gán giá trị đã được mapping (nếu có)
            vulnerability.risk_av = av_mapping.get(av_value, vulnerability.risk_av)
            vulnerability.risk_ac = ac_mapping.get(ac_value, vulnerability.risk_ac)
            vulnerability.risk_pr = pr_mapping.get(pr_value, vulnerability.risk_pr)
            vulnerability.risk_ui = ui_mapping.get(ui_value, vulnerability.risk_ui)

            # 🟢 Liên kết với PentestTask và lưu vào DB
            vulnerability.pentest_task = pentest_task
            vulnerability.save()

            # return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            # formset
            formset = AffectedURLFormSet(request.POST, instance=vulnerability)
            if formset.is_valid():
                formset.save()
                return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            else:
                messages.error(request, f"❌ Lỗi khi lưu11: {form.errors} | Formset: {formset.errors}")
                # return redirect('list_pentest_tasks')
        else:
            # messages.error(request, f"❌ Lỗi khi lưu: {form.errors} | Formset: {formset.errors}")
            formset = AffectedURLFormSet(request.POST)
    else:
        form = VulnerabilityForm()
        formset = AffectedURLFormSet()


    # Tìm kiếm VulnTemplate
    search_query = request.GET.get('search', '')
    vuln_templates = VulnTemplate.objects.filter(name_vuln__icontains=search_query)

    return render(request, "pentest_task/add_vulnerability.html", {
        "form": form,
        'formset': formset,
        "pentest_task": pentest_task,
        'vuln_templates': vuln_templates,
    })


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST, instance=vulnerability)
        formset = AffectedURLFormSet(request.POST, instance=vulnerability)

        if form.is_valid() and formset.is_valid():
            vulnerability = form.save(commit=False)

            # Lưu formset, bỏ qua các form rỗng không có dữ liệu
            instances = formset.save(commit=False)
            for instance in instances:
                # Bỏ qua form rỗng không có dữ liệu
                if not any([instance.vuln_api, instance.request, instance.response, instance.note, instance.poc]):
                    continue
                instance.vulnerability = vulnerability
                instance.save()

            # Xóa các dòng đã được đánh dấu DELETE
            for obj in formset.deleted_objects:
                obj.delete()

            # Cập nhật thủ công các trường CVSS
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)
            vulnerability.risk_av = request.POST.get("risk_av", vulnerability.risk_av)
            vulnerability.risk_ac = request.POST.get("risk_ac", vulnerability.risk_ac)
            vulnerability.risk_pr = request.POST.get("risk_pr", vulnerability.risk_pr)
            vulnerability.risk_ui = request.POST.get("risk_ui", vulnerability.risk_ui)
            vulnerability.save()

            return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
        # else:
        #     messages.error(request, f"❌ Lỗi khi lưu: {form.errors} | Formset: {formset.errors}")
    else:
        form = VulnerabilityForm(instance=vulnerability)
        formset = AffectedURLFormSet(instance=vulnerability)
      
    return render(request, "pentest_task/edit_vulnerability.html", {
        "form": form,
        "formset": formset,
        "pentest_task": pentest_task,
        "vulnerability": vulnerability,
        "empty_form": formset.empty_form,
    })


def risk_summary_data(pentest_task_id):
    # Giá trị mặc định để tránh lỗi 'referenced before assignment'
    risk_summary = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    risk_summary_api = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    # 1. Đếm số lượng Vulnerability theo risk_rating
    risk_counts = (
        Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
        .values("risk_rating")
        .annotate(total=Count("id"))
    )

    for item in risk_counts:
        rating = item["risk_rating"]
        if rating in risk_summary:
            risk_summary[rating] = item["total"]

    # 2. Đếm số lượng affected URL theo từng mức độ rủi ro
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
    for vuln in vulnerabilities:
        url_count = AffectedURL.objects.filter(vulnerability=vuln).count()
        if vuln.risk_rating in risk_summary_api:
            risk_summary_api[vuln.risk_rating] += url_count

    return risk_summary, risk_summary_api


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def list_vulnerabilities(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerabilities = pentest_task.vulnerabilities.all()
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')  # Sắp xếp từ Critical → Low
    risk_summary,risk_summary_api = risk_summary_data(pentest_task_id)
    sum(risk_summary.values())
    # 🔢 Gán Ref ID theo thứ tự risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        expected_ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # Nếu ref khác thì mới cập nhật và save
        if vuln.ref != expected_ref:
            vuln.ref = expected_ref
            vuln.save(update_fields=["ref"])  # ✅ Chỉ lưu field ref
        vuln.api_count= AffectedURL.objects.filter(vulnerability=vuln).count()
        # vuln.affected_url_list = vuln.affected_url.split("\n") if vuln.affected_url else []  # Tạo danh sách URL
        # vuln.api_count = len(vuln.affected_url_list)  # Đếm số lượng API nhưng **không lưu vào DB**

    export_logs = ExportLog.objects.filter(pentest_task=pentest_task).order_by('-export_time')
    # Chuyển đổi export_time sang GMT+7
    bangkok = pytz.timezone('Asia/Bangkok')
    for log in export_logs:
        if log.export_time:
            log.export_time_vn = log.export_time.astimezone(bangkok).strftime('%d/%m/%Y %H:%M:%S')
        else:
            log.export_time_vn = None


    return render(request, "pentest_task/list_vulnerabilities.html", {
        "pentest_task": pentest_task,
        "vulnerabilities": vulnerabilities,
        "risk_summary": risk_summary,
        "risk_summary_api": risk_summary_api,
        "export_logs": export_logs,
    })


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def view_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    # Kiểm tra vulnerability thuộc pentest_task
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    if vulnerability.pentest_task.id != pentest_task_id:
        raise PermissionDenied("Vulnerability không thuộc về Pentest Task này.")

    # Lấy danh sách affected_urls của vulnerability đó
    affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)

    # Kiểm tra từng AffectedURL (phòng khi có dữ liệu bị nhập nhầm DB)
    for url in affected_urls:
        if url.vulnerability_id != vulnerability.id:
            raise PermissionDenied("AffectedURL không khớp với vulnerability.")


    # pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    # # Lấy danh sách affected_urls từ vulnerability
    # affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)
    return render(request, "pentest_task/view_vulnerability.html", {"form": vulnerability, "pentest_task": pentest_task, "affected_urls": affected_urls})


@login_required
@require_groups(['Pentester', 'Leader'])
def delete_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)
    if request.method == "POST":
        messages.success(request, f"Vulnerability {vulnerability.name_vuln} has been deleted successfully.")
        logger.info(f"Vulnerability Deleted: {vulnerability}")  # Ghi log xóa task
        vulnerability.delete()
    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)


@login_required
@require_groups(['Pentester', 'Leader'])
def import_vulnerabilities(request):
    if request.method == "POST" and request.FILES.get("task_file"):
        file = request.FILES["task_file"]
        vulnerabilities = set()
        try:
            handle_uploaded_file(file)
            try:
                xls = pd.ExcelFile(file)
                # Sheet 1: VERIFY TASK
                vuln_df = pd.read_excel(xls, sheet_name="Vulnerability")
                for _, row in vuln_df.iterrows():
                    # pentest_task_name = safe_str(row.get("Task"))
                    
                    # if not pentest_task_name:
                    #     print("⚠️ Bỏ qua dòng vì không có pentest_task_name:", row.to_dict())
                    #     continue
                    ref=safe_str(row.get("REF")) #giá trị ref của vulnerability
                    ref_prefix = "-".join(ref.split("-")[:-1]) # Lấy phần trước dấu "-" để lấy giá trị ref của pentest_task
                    ref_prefix = safe_str(ref_prefix)  
                    name_vuln_row = safe_str(row.get("Issue Description "))
                    
                    try:
                        pentest_task = PentestTask.objects.get(ref=ref_prefix)
                        if pentest_task:
                            print(f"Found pentest_task: {pentest_task}")
                            messages.success(request, f"Đã tìm thấy PentestTask với ref: {pentest_task.ref}")
                            # messages.warning(request, f"Đã tìm thấy PentestTask với ref: {ref_prefix}")
                        else:
                            print("No pentest_task found.")
                            messages.error(request, f"Không tìm thấy PentestTask với ref: {pentest_task.ref}")
                    except PentestTask.DoesNotExist:
                        messages.warning(request, f"Không tìm thấy PentestTask với ref: {ref_prefix}")
                        continue

                    # ✅ Bỏ qua nếu Vulnerability đã tồn tại với pentest_task và name_vuln
                    if Vulnerability.objects.filter(pentest_task=pentest_task, name_vuln=name_vuln_row).exists():
                        print(f"⚠️ Vulnerability '{name_vuln_row}' đã tồn tại cho task '{ref_prefix}', bỏ qua.")
                        continue

                    Vulnerability.objects.create(
                        pentest_task=pentest_task,
                        ref=ref,
                        name_vuln=safe_str(row.get("Issue Description ")),
                        risk_rating=safe_str(row.get("Risk")),
                        notify_date=safe_date(request,row.get("Notify")),
                        status=safe_str(row.get("Status")),
                    )
           
                messages.success(request, "Vulnerability imported successfully")
            except Exception as e:
                messages.error(request, f"❌ Error in Vuln: {e}, row: {row.to_dict()}")
        except ValidationError as e:
            return HttpResponseBadRequest(str(e))   
        return redirect("pentest_task:list_pentest_tasks")


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_all_vulnerabilities(request):
    vulnerabilities = Vulnerability.objects.select_related("pentest_task").filter(
        name_vuln__isnull=False
    ).exclude(name_vuln="")

    total_count = vulnerabilities.count()
    open_count = vulnerabilities.filter(status="Open").count()
    high_risk_count = vulnerabilities.filter(risk_rating="High").count()

    return render(request, "pentest_task/list_all_vulnerabilities.html", {
        "vulnerabilities": vulnerabilities,
        "total_count": total_count,
        "open_count": open_count,
        "high_risk_count": high_risk_count,
    })
    

def convert_text(text):
    evidence_parts = []
    # html_content = markdown.markdown(text)
    html_content = markdown.markdown(
        text,
        extensions=["fenced_code", "codehilite"]
    )
    soup = BeautifulSoup(html_content, "html.parser")
    image_pattern = re.compile(r'!\[.*?\]\(data:image/.*?;base64,(.*?)\)', re.DOTALL)
    for element in soup.children:
        rt = RichText() 
        rt_code = RichText()
        rt_precode = RichText()
        rt_list = RichText()
        
        if element.name in ["h1", "h2", "h3"]:
            rt.add("\n")
            rt.add(element.text.strip(), bold=True,italic=True, size=37)
            rt.add("\n")
            evidence_parts.append({"type": "text", "content": rt})
            
        elif element.name == "blockquote":
            quote_text = element.get_text(strip=True)
            formatted = "\n> " + quote_text.replace("\n", "\n> ") + "\n"
            rt.add(formatted, italic=True, color="#555555")  
            evidence_parts.append({"type": "text", "content": rt})
        # Handle horizontal rule
        elif element.name == "hr":
            rt.add("-" * 30)
            evidence_parts.append({"type": "text", "content": rt})
           
        elif element.name == "p":
            for child in element.children:
                name = getattr(child, "name", None)
                if name == "strong":
                    rt.add(child.text, bold=True)
                    
                elif name == "em":
                    rt.add(child.text, italic=True)
                    
                elif name in ["h1", "h2", "h3"]:
                    rt.add(element.text.upper(), bold=True,size=23)
                    
                elif name == "code":
                    rt_code.add(child.text.strip(), italic=True, font="Consolas", color="#8B0000")
                    
                elif name is None:
                    rt.add(str(child))
                else:
                    rt.add(str(child))
                    
            evidence_parts.append({"type": "text", "content": rt})
            evidence_parts.append({"type": "code", "content": rt_code})
       
        elif element.name == "pre":
            code = element.find("code")
            code_text = code.get_text() if code else element.get_text()
            rt_precode.add(code_text.strip(), font="Consolas", size=20, color="#555555")
            evidence_parts.append({"type": "precode", "content": rt_precode})

        # list
        elif element.name == "ul":
            list_items = element.find_all("li", recursive=False)
            if list_items:
                rt = RichText()
                for li in list_items:
                    rt.add("• ", bold=True)
                    rt.add(li.get_text(strip=True))
                    rt.add("\n")
                evidence_parts.append({"type": "text", "content": rt})
        # number list
        elif element.name == "ol":
            list_items = element.find_all("li", recursive=False)
            if list_items:
                for idx, li in enumerate(list_items, start=1):
                    rt = RichText()
                    rt.add(f"{idx}. ", bold=True)
                    rt.add(li.get_text(strip=True),bold=True)
                    rt.add("\n")
                    evidence_parts.append({"type": "text", "content": rt})

        # ==== FALLBACK ====
        else:
            rt.add(element.get_text())
            evidence_parts.append({"type": "text", "content": rt})

    return evidence_parts


def parse_evidence(evidence_md, doc):
    parts = []
    # Bắt cả alt_text (caption) và image_data
    image_pattern = re.compile(r"!\[(.*?)\]\(data:image/.*?;base64,(.*?)\)")
    pos = 0
    rt = RichText()

    for match in image_pattern.finditer(evidence_md):
        start, end = match.span()

        # Phần text trước ảnh
        if start > pos:
            text = evidence_md[pos:start].strip()
            if text:
                parts.extend(convert_text(text))

        # Lấy caption và ảnh
        alt_text = match.group(1)
        image_data = match.group(2)
        image_bytes = base64.b64decode(image_data)
        image_stream = BytesIO(image_bytes)
        image = InlineImage(doc, image_stream, width=Mm(130))
        parts.append({'type': 'image', 'content': image})

        # Caption dưới ảnh
        caption_rt = RichText()
        caption_rt.add(alt_text.strip(), italic=True, color="#666666")
        parts.append({'type': 'caption', 'content': caption_rt})

        pos = end

    # Phần còn lại sau ảnh cuối
    if pos < len(evidence_md):
        remaining_text = evidence_md[pos:].strip()
        if remaining_text:
            parts.extend(convert_text(remaining_text))

    return parts


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_pentest_report(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    appsec_task = pentest_task.appsec_task

    if not pentest_task.ref:
        messages.error(request, "⚠️Provide unique REF and create report pentest again")
        return redirect("pentest_task:list_vulnerabilities", pentest_task_id=pentest_task.id)  # hoặc thay bằng trang phù hợp

    # Lấy danh sách vulnerabilities, sắp xếp theo risk_score (cao -> thấp)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')
    risk_summary,_ = risk_summary_data(pentest_task_id)
    
    # Load file Word từ template
    template = ReportConfig.get_current_template()
    if not template:
        raise Exception("Chưa cấu hình template báo cáo.")
    doc = DocxTemplate(template.file.path)

    # kiểm tra nếu vuln.notify_date is None thì gán ngày export là notify_date


    # template_path = os.path.join(settings.BASE_DIR, "templates/report", "pentest_template.docx")
    # doc = DocxTemplate(template_path)
    
    #Tạo danh sách Ref ID theo thứ tự risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        if not vuln.notify_date:
            vuln.notify_date = timezone.now().date()
        vuln.save()  # Cập nhật ref vào DB
    
    # Xử lý dữ liệu thời gian & kiểm tra `None`
    def safe_date(date_value, format_str="%d/%m/%Y"):
        return date_value.strftime(format_str) if date_value else ""

    # Chuyển đổi danh sách API từ trường `scope`
    scope_list = pentest_task.scope.splitlines() if pentest_task.scope else []
    scope_table = [{"No": idx + 1, "API": api} for idx, api in enumerate(scope_list)]

    # Định nghĩa màu chữ cho từng mức độ risk rating (dùng HEX màu Word)
    risk_text_colors = {
        "Critical": "8B0000",  # Đỏ đậm
        "High": "FF0000",      # Đỏ
        "Medium": "FFA500",    # Cam
        "Low": "008000",       # Xanh lá đậm
        "Recommend": "32CD32"  # Xanh lá nhạt
    }
    # sắp xếp vuln theo risk_score giảm dần    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    placeholder_vulns = []
    for vuln in vulnerabilities:
        color = risk_text_colors.get(vuln.risk_rating, "000000")  # Mặc định là Đen (000000)
        color_likelihood_rate = risk_text_colors.get(vuln.likelihood_rate, "000000")  # Mặc định là Đen (000000)
        color_impact_rate = risk_text_colors.get(vuln.impact_rate, "000000")  # Mặc định là Đen (000000)

        # Lấy danh sách affected_url từ model mới
        affected_url_qs = AffectedURL.objects.filter(vulnerability=vuln)
        affected_url_table = [
            {
                "No": idx + 1,
                "Function": url.function or "",
                "API": url.vuln_api or "",
                "Params": url.params or "",
            }
            for idx, url in enumerate(affected_url_qs)
        ]


        # Format XML để Word hiểu màu chữ
        risk_rating_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>'
        risk_score_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>'
        risk_likelihood_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_likelihood_rate}"/></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>'
        risk_impact_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_impact_rate}"/></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>'
        placeholder_vulns.append({
                "ref": vuln.ref,
                "name_vuln": vuln.name_vuln,
                "description":vuln.description,
                "risk_score": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>',
                "risk_vector": vuln.risk_vector,
                "risk_rating": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>',
                "likelihood_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.likelihood_rate, "000000")}" /></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>',
                "impact_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.impact_rate, "000000")}" /></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>',
                # "likelihood": vuln.likelihood,
                "risk_av": vuln.risk_av,
                "risk_ac": vuln.risk_ac,
                "risk_pr": vuln.risk_pr,
                "risk_ui": vuln.risk_ui,
                "impact": vuln.impact,
                "evidence_parts": parse_evidence(vuln.evidence, doc),
                "affected_url_table": affected_url_table,
                # "api_count": len(vuln.affected_url.split("\n")) if vuln.affected_url else 0,  # Đếm số API
                "recommendation": vuln.recommendation,
                "reference": vuln.reference,
                "status": vuln.status,
            })
   

    placeholders = {
        "task_name": str(pentest_task.name) if pentest_task.name else "",
        "scope": scope_table,
        "today": datetime.today().strftime("%B %d %Y"),  # "March 06 2024"
        "component": str(pentest_task.component) if pentest_task.component else "",
        "start_date": safe_date(pentest_task.start_date, "%B %d %Y"),
        "start_month": safe_date(pentest_task.start_date, "%B"),
        "start_year": str(pentest_task.start_date.year) if pentest_task.start_date else "",
        "end_date": safe_date(pentest_task.end_date, "%B %d %Y"),
        "total_vulnerabilities": str(sum(risk_summary.values())),
        "count_critical": str(risk_summary.get("Critical", 0)),
        "count_high": str(risk_summary.get("High", 0)),
        "count_medium": str(risk_summary.get("Medium", 0)),
        "count_low": str(risk_summary.get("Low", 0)),
        "count_recommend": str(risk_summary.get("Recommend", 0)),
        "environment_prod": str(appsec_task.environment_prod) if appsec_task.environment_prod else "",
        "environment_test": str(pentest_task.environment_test) if pentest_task.environment_test else "",
        "vulnerabilities": placeholder_vulns

    }
        # Truyền vào word:    Task Name: {{ task_name }}
        # Component: {{ component }}
        # Start Date: {{ start_date }}
        # {% for vuln in vulnerabilities %} {{vuln.name_vuln}} {% endfor %} 

    # Điền dữ liệu vào template
    doc.render(placeholders)
    # ✅ Ghi log export report
    ExportLog.objects.create(
        pentest_task=pentest_task,
        user=request.user
    )


    # Xuất file Word với dữ liệu đã thay thế
    response = HttpResponse(content_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
    response["Content-Disposition"] = f'attachment; filename="Pentest_Report_{pentest_task.name}.docx"'
    doc.save(response)

    return response


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_details_vulnerability_excel(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id).prefetch_related('affected_urls')
    # sắp xếp vuln theo risk_score giảm dần    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    affected_data = []
    for vuln in vulnerabilities:
        for au in vuln.affected_urls.all():
            affected_data.append({
                "Vuln Name": vuln.name_vuln or "",
                "Ref ID": vuln.ref or "",
                "Risk Rating":vuln.risk_rating or "",
                "Function Name": au.function or "",
                "Vuln API": au.vuln_api or "",
                "Request": au.request or "",
                "Response": au.response or "",
                "Params": au.params or "",
                "Note": au.note or "",
                "POC": au.poc or "",  # POC là markdown text (có thể chứa ảnh base64)
            })

    df = pd.DataFrame(affected_data)

    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name="Affected URLs", index=False)
        workbook  = writer.book
        worksheet = writer.sheets["Affected URLs"]

        # Định dạng kích thước cột và dòng
        worksheet.set_column('A:H', 70)  # Tăng độ rộng các cột
        for row in range(1, len(df) + 1):
            worksheet.set_row(row, 170)  # Chiều cao dòng cố định

        # Duyệt lại từng dòng để xử lý POC
        image_pattern = re.compile(r"!\[.*?\]\(data:image/.*?;base64,(.*?)\)")

        for i, poc_md in enumerate(df["POC"]):
            cell_row = i + 1
            text_part = image_pattern.split(poc_md)[0].strip()

            # Ghi phần text của POC (nếu có)
            if text_part:
                worksheet.write(cell_row, len(df.columns)-1, text_part)

            # Chèn ảnh (nếu có)
            for match in image_pattern.finditer(poc_md):
                image_data = match.group(1)
                try:
                    image_bytes = base64.b64decode(image_data)
                    image_stream = BytesIO(image_bytes)

                    # Kiểm tra hợp lệ
                    img = Image.open(image_stream)
                    img.verify()
                    image_stream.seek(0)

                    worksheet.insert_image(
                        cell_row,
                        len(df.columns)-1,
                        "image.png",
                        {
                            'image_data': image_stream,
                            'x_scale': 1,
                            'y_scale': 1,
                            'positioning': 1,
                        }
                    )
                except Exception as e:
                    print(f"⚠️ Lỗi chèn ảnh dòng {cell_row}: {e}")

    output.seek(0)
    filename = f"details_vuln_of_{pentest_task.name}.xlsx"
    response = HttpResponse(output, content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename={filename}'

    return response


@login_required
@require_groups(['Pentester', 'Leader'])
@csrf_exempt
def martor_upload_image(request):
    try:
        print("🟢 Đã gọi martor_upload_image")
        print("Upload method:", PETEREPORT_MARKDOWN.get("martor_upload_method"))
        print("Upload path:", MARTOR_UPLOAD_PATH)

        if request.method == 'POST' and request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            if 'markdown-image-upload' in request.FILES:
                image = request.FILES['markdown-image-upload']
                print("📷 Đã nhận file:", image.name, image.content_type)

                # Kiểm tra định dạng
                image_types = [
                    'image/png', 'image/jpg', 'image/jpeg', 'image/pjpeg', 'image/gif'
                ]
                if image.content_type not in image_types:
                    return JsonResponse({'status': 405, 'error': 'Bad image format.'}, status=405)

                if image.size > MAX_IMAGE_UPLOAD_SIZE:
                    return JsonResponse({
                        'status': 405,
                        'error': f'Maximum image file is {MAX_IMAGE_UPLOAD_SIZE / (1024 * 1024)} MB.'
                    }, status=405)

                if PETEREPORT_MARKDOWN['martor_upload_method'] == 'BASE64':
                    image_content_base64 = base64.b64encode(image.read()).decode('utf-8')
                    image_content_base64_final = f'data:{image.content_type};base64,{image_content_base64}'
                    return JsonResponse({
                        'status': 200,
                        'link': image_content_base64_final,
                        'name': image.name
                    })

                elif PETEREPORT_MARKDOWN['martor_upload_method'] == 'MEDIA':
                    today = datetime.date.today().strftime('%Y/%m/%d/')
                    img_uuid = f"{uuid.uuid4().hex[:32]}-{image.name.replace(' ', '-')}"
                    tmp_path = os.path.join(MARTOR_UPLOAD_PATH, today, img_uuid)

                    print("📁 Lưu file vào:", tmp_path)

                    def_path = default_storage.save(tmp_path, ContentFile(image.read()))
                    img_url = os.path.join(MARTOR_MEDIA_URL, def_path)

                    return JsonResponse({
                        'status': 200,
                        'link': img_url,
                        'name': image.name
                    })

        return JsonResponse({'status': 400, 'error': 'Invalid request!'}, status=400)

    except Exception as e:
        print("❌ Exception xảy ra khi upload:", str(e))
        return JsonResponse({'error': str(e)}, status=500)


#chức năng tạo template
@login_required
@require_groups(['Pentester', 'Leader'])
def save_to_template(request, vuln_id):
    vuln = get_object_or_404(Vulnerability, id=vuln_id)
    
    # Kiểm tra xem template có tồn tại chưa
    template, created = VulnTemplate.objects.update_or_create(
        name_vuln=vuln.name_vuln,  # Tạo mới hoặc cập nhật nếu trùng tên
        defaults={
            'risk_score': vuln.risk_score,
            'risk_vector': vuln.risk_vector,
            'risk_rating': vuln.risk_rating,
            'description': vuln.description,
            'likelihood_rate': vuln.likelihood_rate,
            'risk_av': vuln.risk_av,
            'risk_ac': vuln.risk_ac,
            'risk_pr': vuln.risk_pr,
            'risk_ui': vuln.risk_ui,
            'impact_rate': vuln.impact_rate,
            'impact': vuln.impact,
            'recommendation': vuln.recommendation,
            'reference': vuln.reference,
        }
    )

    if created:
        messages.success(request, f"Template '{vuln.name_vuln}' was updated.")
    else:
        messages.info(request, f"Template '{vuln.name_vuln}' was updated.")

    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=vuln.pentest_task_id)


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_vuln_templates(request):
    templates = VulnTemplate.objects.all()
    return render(request, 'pentest_task/list_vuln_templates.html', {'vulnerabilities': templates})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def view_vuln_template(request, vuln_template_id):
    vuln_template = get_object_or_404(VulnTemplate, id=vuln_template_id)
    return render(request, 'pentest_task/view_vuln_template.html', {'form': vuln_template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_create(request):
    form = VulnTemplateForm(request.POST or None)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_edit(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    form = VulnTemplateForm(request.POST or None, instance=template)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form, 'template': template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_delete(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    if request.method == "POST":
        template.delete()
    return redirect('pentest_task:list_vuln_templates')  # Quay lại danh sách ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def my_task_view(request):
    my_tasks = PentestTask.objects.filter(PIC_ISM=request.user)
    return render(request, 'pentest_task/my_tasks.html', {'tasks': my_tasks})


@login_required
@require_groups(['Pentester', 'Leader'])
def list_templates(request):
    templates = TemplateReport.objects.all()
    current_config = ReportConfig.objects.first()
    current_template_id = current_config.current_template.id if current_config and current_config.current_template else None

    if request.method == "POST":
        selected_id = request.POST.get("selected_template")
        selected_template = TemplateReport.objects.get(id=selected_id)

        if not current_config:
            current_config = ReportConfig(current_template=selected_template)
        else:
            current_config.current_template = selected_template

        current_config.save()
        return redirect("pentest_task:list_templates")

    return render(request, "pentest_task/report_template/list_templates.html", {
        "templates": templates,
        "current_template_id": current_template_id,
    })


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_template(request, pk):
    template = get_object_or_404(TemplateReport, pk=pk)
    if request.method == "POST":
        form = TemplateReportForm(request.POST, request.FILES, instance=template)
        if form.is_valid():
            file = request.FILES["file"]
            try:
                handle_uploaded_file(file)
        
                form.save()
                messages.success(request, "Update report template successfully.")
            except ValidationError as e:
                return HttpResponseBadRequest(str(e))
            return redirect("pentest_task:list_templates")
    else:
        form = TemplateReportForm(instance=template)
    return render(request, "pentest_task/report_template/edit_template.html", {"form": form, "template": template})


@login_required
@require_groups(['Pentester', 'Leader'])
def delete_template(request, pk):
    template = get_object_or_404(TemplateReport, pk=pk)
    if request.method == "POST":
        template.delete()
        messages.success(request, "Deleted report template successfully.")
        return redirect("pentest_task:list_templates")
    return render(request, "pentest/report_template/delete_template.html", {"template": template})


@login_required
@require_groups(['Pentester', 'Leader'])
def upload_template(request):
    if request.method == "POST":
        form = TemplateReportForm(request.POST, request.FILES)
        if form.is_valid():
            file = request.FILES["file"]
            try:
                handle_uploaded_file(file)
            
                form.save()
            except ValidationError as e:
                return HttpResponseBadRequest(str(e))
            return redirect("pentest_task:list_templates")
    else:
        form = TemplateReportForm()

    return render(request, "pentest_task/report_template/upload_template.html", {
        "form": form
    })


def select_template(request, template_id):
    template = get_object_or_404(TemplateReport, id=template_id)
    config = ReportConfig.objects.first()
    if not config:
        config = ReportConfig.objects.create(current_template=template)
    else:
        config.current_template = template
        config.save()
    return redirect("pentest_task:list_templates")  # hoặc tên URL của trang danh sách template


def custom_404_view(request, exception):
    return render(request, "404.html", status=404)

