from django.shortcuts import render, redirect
from django.shortcuts import get_object_or_404
from django.contrib import messages
from django.conf import settings
from django.http import HttpResponse
from django.db.models import Count
from datetime import datetime
from collections import OrderedDict
import os
import pandas as pd
from docxtpl import DocxTemplate, InlineImage, RichText, Subdoc
import logging
import base64
from io import BytesIO
from PIL import Image
import re
from docx.shared import Mm
import openpyxl
import markdown2
from bs4 import BeautifulSoup
from docx.shared import Inches
import markdown
from martor.utils import LazyEncoder
from datetime import datetime, date
import pytz

#upload file evidence
import uuid
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from xlsxwriter.utility import xl_rowcol_to_cell


from .forms import  PentestTaskForm, VulnerabilityForm, AffectedURLForm, AffectedURLFormSet, VulnTemplateForm, TemplateReportForm
from .models import PentestTask, Vulnerability, AffectedURL, ExportLog, VulnTemplate, Notification, TemplateReport, ReportConfig
from appsec_task.models import AppSecTask
from appsec_task.views import sync_status, handle_uploaded_file
from task_manager.decorators import require_groups

from django.forms import inlineformset_factory
from django.forms.models import model_to_dict
from django.core.exceptions import PermissionDenied
from django.utils import timezone
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User

# Martor
from task_manager.settings import MAX_IMAGE_UPLOAD_SIZE, MARTOR_UPLOAD_PATH, MEDIA_URL, MEDIA_ROOT, TEMPLATES_ROOT, REPORTS_MEDIA_ROOT, SERVER_CONF, TEMPLATES_DIRECTORIES, MARTOR_MEDIA_URL
# PeTeReport config for Martor
from pentest_task.petereport_config import PETEREPORT_MARKDOWN, PETEREPORT_TEMPLATES, DEFECTDOJO_CONFIG, PETEREPORT_CONFIG
from django.core.exceptions import ValidationError
from django.http import HttpResponseBadRequest
import magic  # check MIME type


# from . import export_report
logger = logging.getLogger(__name__)


status_colors = {
        "Not Started": "bg-info",
        "In Progress": "bg-warning text-dark",
        "Reported": "bg-primary",
        "Retest": "bg-danger",
        "Interrupt": "bg-danger text-dark",
        "Done": "bg-success",
        "Cancel": "bg-danger text-dark",
    }

def safe_str(value):
    return "" if pd.isna(value) or value is None else str(value).strip()

def safe_int(value):
    try:
        return int(value) if not pd.isna(value) and str(value).strip().isdigit() else None
    except ValueError:
        return None

def safe_date(request, val):
    try:
        if pd.isna(val):
            return None
        if isinstance(val, (datetime, date, pd.Timestamp)):
            return val.date() if isinstance(val, pd.Timestamp) else val
        return pd.to_datetime(str(val)).date()
    except Exception as e:
        # print(f"‚ùå safe_date error: {e}, val: {val}")
        messages.error(request,f"‚ùå safe_date error: {e}, val: {val}")
        return None


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def get_notifications(request):
    # L·∫•y t·∫•t c·∫£ th√¥ng b√°o ch∆∞a ƒë·ªçc c·ªßa ng∆∞·ªùi d√πng
    notifications = Notification.objects.filter(user=request.user).order_by('-created_at')
    unread_notis = Notification.objects.filter(user=request.user, is_read=False)
    
    # T·∫°o danh s√°ch th√¥ng b√°o cho response
    notif_list = []
    for notif in notifications:
        notif_list.append({
            'id': notif.id,
            'title': notif.title,
            'description': notif.description,
            'created_at': notif.created_at.strftime('%d/%m/%Y %H:%M:%S'),  # G·ª≠i gi·ªù UTC cho created_at
            'created_at_vn': notif.created_at_vn,  # G·ª≠i gi·ªù theo GMT+7 cho created_at_vn
            'url': notif.url,
            'is_read': notif.is_read,
        })
    
    # Tr·∫£ v·ªÅ th√¥ng b√°o d·∫°ng JSON
    return JsonResponse({'notifications': notif_list, 'notis_count': len(notif_list), 'unread_notis_count': len(unread_notis) })


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def mark_notification_as_read(request, notif_id):
    # L·∫•y th√¥ng b√°o t·ª´ ID
    notification = get_object_or_404(Notification, id=notif_id, user=request.user)
    notification.is_read = True
    notification.save()
    return JsonResponse({'status': 'success'})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_pentest_tasks(request):
    tasks = PentestTask.objects.all()
    return render(request, 'pentest_task/list_pentest_tasks.html', {'tasks': tasks, "status_colors":status_colors})


@login_required
@require_groups(['Pentester', 'Leader'])
def create_pentest_task(request, appsec_task_id):
    appsec_task = get_object_or_404(AppSecTask, id=appsec_task_id)

    if request.method == "POST":
        form = PentestTaskForm(request.POST)
        if form.is_valid():
            pentest_task = form.save(commit=False)

            # FIX QUAN TR·ªåNG: g√°n AppSecTask ƒë√∫ng
            pentest_task.appsec_task = appsec_task
            pentest_task.name=appsec_task.name
            pentest_task.PIC_ISM = form.cleaned_data.get('PIC_ISM', '')

            #  sync status v·ªõi appsec_task
            sync_status(appsec_task.id)
            pentest_task.save()
            old_assignee = ""
            old_assignees = set([x.strip() for x in old_assignee.split(",") if x.strip()])
            new_assignees = set([x.strip() for x in pentest_task.PIC_ISM.split(",") if x.strip()])

            # G·ª≠i noti cho nh·ªØng ng∆∞·ªùi m·ªõi ƒë∆∞·ª£c th√™m v√†o
            added_users = new_assignees - old_assignees

            for username in added_users:
                try:
                    user = User.objects.get(username=username)
                    Notification.objects.create(
                        user=user,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{pentest_task.id}",
                    )
                except User.DoesNotExist:
                    continue
    
            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(initial={"name": appsec_task.name, "description": appsec_task.description})  # G√°n tr∆∞·ªõc v√†o form
        
    return render(request, "pentest_task/create_pentest_task.html", {"form": form, "appsec_task": appsec_task,'usernames': form.usernames_json})


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)
    old_assignee = task.PIC_ISM

    appsec_task = task.appsec_task  # L·∫•y AppSecTask li√™n k·∫øt
    if request.method == "POST":
        form = PentestTaskForm(request.POST, instance=task)
        if form.is_valid():
            pentest_task = form.save(commit=False)
            pentest_task.appsec_task = appsec_task 
            sync_status(appsec_task.id)
            pentest_task.save()

            old_assignees = set([x.strip() for x in old_assignee.split(",") if x.strip()])
            new_assignees = set([x.strip() for x in pentest_task.PIC_ISM.split(",") if x.strip()])

            # G·ª≠i noti cho nh·ªØng ng∆∞·ªùi m·ªõi ƒë∆∞·ª£c th√™m v√†o
            added_users = new_assignees - old_assignees

            for username in added_users:
                try:
                    user = User.objects.get(username=username)
                    Notification.objects.create(
                        user=user,
                        title="New Pentest Task Assigned",
                        description=f"You are assigned to Pentest task: {pentest_task.name}",
                        url=f"/pentest/view/{pentest_task.id}",
                    )
                except User.DoesNotExist:
                    continue
            return redirect("pentest_task:list_pentest_tasks")
    else:
        form = PentestTaskForm(instance=task, initial={"name": appsec_task.name, "description": appsec_task.description})  # G√°n tr∆∞·ªõc v√†o form


    return render(request, "pentest_task/edit_pentest_task.html", {"form": form, "task": task, "appsec_task": appsec_task, 'usernames': form.usernames_json})


@login_required
@require_groups(['Pentester', 'Leader'])
def view_pentest_task(request, task_id):
    pentest_task = get_object_or_404(PentestTask, id=task_id)
    appsec_task = pentest_task.appsec_task  # L·∫•y AppSecTask li√™n k·∫øt
    
    form = PentestTaskForm(instance=pentest_task)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('risk_rating')  # S·∫Øp x·∫øp t·ª´ Critical ‚Üí Low
    context = {
        "form": pentest_task,
        "vulnerabilities": vulnerabilities,
        "appsec_task": appsec_task,
    }
    return render(request, "pentest_task/view_pentest_task.html", context)
 

@login_required
@require_groups(['Pentester', 'Leader'])
def delete_pentest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id)

    if request.method == "POST":
        logger.info(f"Task Deleted: {task}")  # Ghi log x√≥a task
        task.delete()
    
    return redirect('pentest_task:list_pentest_tasks')  # Quay l·∫°i danh s√°ch ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def create_retest_task(request, task_id):
    task = get_object_or_404(PentestTask, id=task_id, status="Reported")  # L·∫•y task g·ªëc

    if request.method == "POST":
        start_retest = request.POST.get("start_retest") or None
        end_retest = request.POST.get("end_retest") or None
            
        if start_retest and end_retest and start_retest > end_retest:
            messages.error(request, "Start Retest date must be before or equal to End Retest date.")
        if messages.get_messages(request):
            return render(request, "pentest_task/create_retest_task.html",{'task':task})
    
        else:
            task.status="Retest"
            task.PIC_ISM=request.POST.get("PIC_ISM")
            task.start_retest=start_retest
            task.end_retest=end_retest

            task.save()
            messages.success(request, "Retest Task created successfully!")
            return redirect('pentest_task:list_pentest_tasks')
    
    return render(request, "pentest_task/create_retest_task.html", {"task": task})


@login_required
@require_groups(['Pentester', 'Leader'])
def list_retest_tasks(request):
    retest_tasks = PentestTask.objects.filter(status="Retest")  # L·ªçc c√°c task c√≥ status "Retest"
    
    return render(request, "pentest_task/list_retest_tasks.html", {
        "tasks": retest_tasks,
        "status_colors": status_colors
    })


@login_required 
@require_groups(['Pentester', 'Leader'])
def get_vuln_template_suggestions(request):
    query = request.GET.get('query', '')  # Nh·∫≠n chu·ªói t√¨m ki·∫øm t·ª´ ng∆∞·ªùi d√πng
    templates = VulnTemplate.objects.filter(name_vuln__icontains=query)  # T√¨m ki·∫øm theo t√™n l·ªó h·ªïng
    results = [{'id': tmpl.id, 
                'name_vuln': tmpl.name_vuln, 
                'risk_score': tmpl.risk_score,  # Tr·∫£ v·ªÅ description
                'risk_vector': tmpl.risk_vector,             # Tr·∫£ v·ªÅ impact
                'risk_rating': tmpl.risk_rating,  # Tr·∫£ v·ªÅ recommendation
                'description': tmpl.description, 
                'likelihood_rate': tmpl.likelihood_rate,  # Tr·∫£ v·ªÅ description
                'risk_av': tmpl.risk_av,             # Tr·∫£ v·ªÅ impact
                'risk_ac': tmpl.risk_ac, # Tr·∫£ v·ªÅ recommendation
                'risk_pr': tmpl.risk_pr, 
                'risk_ui': tmpl.risk_ui,  # Tr·∫£ v·ªÅ description
                'impact_rate': tmpl.impact_rate,             # Tr·∫£ v·ªÅ impact
                'impact': tmpl.impact,# Tr·∫£ v·ªÅ recommendation
                'recommendation': tmpl.recommendation, 
                'reference': tmpl.reference,  # Tr·∫£ v·ªÅ description
                }
               for tmpl in templates]  # L·∫•y danh s√°ch k·∫øt qu·∫£
    return JsonResponse({'results': results})  # Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON


@login_required
@require_groups(['Pentester', 'Leader'])
def add_vulnerability(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST)
        if form.is_valid():
            vulnerability = form.save(commit=False)

            # üü¢ L·∫•y v√† l∆∞u c√°c gi√° tr·ªã CVSS
            # vulnerability.risk_score = request.POST.get("risk_score", "").strip()
            # vulnerability.risk_rating = request.POST.get("risk_rating", "").strip()
            # vulnerability.risk_vector = request.POST.get("risk_vector", "").strip()
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)

            # üü¢ L·∫•y gi√° tr·ªã AV, AC, PR, UI t·ª´ request ho·∫∑c gi·ªØ nguy√™n gi√° tr·ªã c≈©
            av_value = request.POST.get("risk_av", "").strip() or vulnerability.risk_av
            ac_value = request.POST.get("risk_ac", "").strip() or vulnerability.risk_ac
            pr_value = request.POST.get("risk_pr", "").strip() or vulnerability.risk_pr
            ui_value = request.POST.get("risk_ui", "").strip() or vulnerability.risk_ui

            # üü¢ Mapping gi√° tr·ªã th√†nh d·∫°ng th√¢n thi·ªán
            av_mapping = {"N": "Network", "A": "Adjacent", "L": "Local", "P": "Physical"}
            ac_mapping = {"L": "Low", "H": "High"}
            pr_mapping = {"N": "None", "L": "Low", "H": "High"}
            ui_mapping = {"N": "None", "R": "Required"}

            # üü¢ G√°n gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c mapping (n·∫øu c√≥)
            vulnerability.risk_av = av_mapping.get(av_value, vulnerability.risk_av)
            vulnerability.risk_ac = ac_mapping.get(ac_value, vulnerability.risk_ac)
            vulnerability.risk_pr = pr_mapping.get(pr_value, vulnerability.risk_pr)
            vulnerability.risk_ui = ui_mapping.get(ui_value, vulnerability.risk_ui)

            # üü¢ Li√™n k·∫øt v·ªõi PentestTask v√† l∆∞u v√†o DB
            vulnerability.pentest_task = pentest_task
            vulnerability.save()

            # return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            # formset
            formset = AffectedURLFormSet(request.POST, instance=vulnerability)
            if formset.is_valid():
                formset.save()
                return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
            else:
                messages.error(request, f"‚ùå L·ªói khi l∆∞u11: {form.errors} | Formset: {formset.errors}")
                # return redirect('list_pentest_tasks')
        else:
            # messages.error(request, f"‚ùå L·ªói khi l∆∞u: {form.errors} | Formset: {formset.errors}")
            formset = AffectedURLFormSet(request.POST)
    else:
        form = VulnerabilityForm()
        formset = AffectedURLFormSet()


    # T√¨m ki·∫øm VulnTemplate
    search_query = request.GET.get('search', '')
    vuln_templates = VulnTemplate.objects.filter(name_vuln__icontains=search_query)

    return render(request, "pentest_task/add_vulnerability.html", {
        "form": form,
        'formset': formset,
        "pentest_task": pentest_task,
        'vuln_templates': vuln_templates,
    })


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)

    if request.method == "POST":
        form = VulnerabilityForm(request.POST, instance=vulnerability)
        formset = AffectedURLFormSet(request.POST, instance=vulnerability)

        if form.is_valid() and formset.is_valid():
            vulnerability = form.save(commit=False)

            # L∆∞u formset, b·ªè qua c√°c form r·ªóng kh√¥ng c√≥ d·ªØ li·ªáu
            instances = formset.save(commit=False)
            for instance in instances:
                # B·ªè qua form r·ªóng kh√¥ng c√≥ d·ªØ li·ªáu
                if not any([instance.vuln_api, instance.request, instance.response, instance.note, instance.poc]):
                    continue
                instance.vulnerability = vulnerability
                instance.save()

            # X√≥a c√°c d√≤ng ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u DELETE
            for obj in formset.deleted_objects:
                obj.delete()

            # C·∫≠p nh·∫≠t th·ªß c√¥ng c√°c tr∆∞·ªùng CVSS
            vulnerability.risk_score = request.POST.get("risk_score", vulnerability.risk_score)
            vulnerability.risk_rating = request.POST.get("risk_rating", vulnerability.risk_rating)
            vulnerability.risk_vector = request.POST.get("risk_vector", vulnerability.risk_vector)
            vulnerability.risk_av = request.POST.get("risk_av", vulnerability.risk_av)
            vulnerability.risk_ac = request.POST.get("risk_ac", vulnerability.risk_ac)
            vulnerability.risk_pr = request.POST.get("risk_pr", vulnerability.risk_pr)
            vulnerability.risk_ui = request.POST.get("risk_ui", vulnerability.risk_ui)
            vulnerability.save()

            return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)
        # else:
        #     messages.error(request, f"‚ùå L·ªói khi l∆∞u: {form.errors} | Formset: {formset.errors}")
    else:
        form = VulnerabilityForm(instance=vulnerability)
        formset = AffectedURLFormSet(instance=vulnerability)
      
    return render(request, "pentest_task/edit_vulnerability.html", {
        "form": form,
        "formset": formset,
        "pentest_task": pentest_task,
        "vulnerability": vulnerability,
        "empty_form": formset.empty_form,
    })


def risk_summary_data(pentest_task_id):
    # Gi√° tr·ªã m·∫∑c ƒë·ªãnh ƒë·ªÉ tr√°nh l·ªói 'referenced before assignment'
    risk_summary = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    risk_summary_api = {
        "Critical": 0,
        "High": 0,
        "Medium": 0,
        "Low": 0,
        "Recommend": 0,
    }
    # 1. ƒê·∫øm s·ªë l∆∞·ª£ng Vulnerability theo risk_rating
    risk_counts = (
        Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
        .values("risk_rating")
        .annotate(total=Count("id"))
    )

    for item in risk_counts:
        rating = item["risk_rating"]
        if rating in risk_summary:
            risk_summary[rating] = item["total"]

    # 2. ƒê·∫øm s·ªë l∆∞·ª£ng affected URL theo t·ª´ng m·ª©c ƒë·ªô r·ªßi ro
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id)
    for vuln in vulnerabilities:
        url_count = AffectedURL.objects.filter(vulnerability=vuln).count()
        if vuln.risk_rating in risk_summary_api:
            risk_summary_api[vuln.risk_rating] += url_count

    return risk_summary, risk_summary_api


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def list_vulnerabilities(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerabilities = pentest_task.vulnerabilities.all()
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')  # S·∫Øp x·∫øp t·ª´ Critical ‚Üí Low
    risk_summary,risk_summary_api = risk_summary_data(pentest_task_id)
    sum(risk_summary.values())
    # üî¢ G√°n Ref ID theo th·ª© t·ª± risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        expected_ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        # N·∫øu ref kh√°c th√¨ m·ªõi c·∫≠p nh·∫≠t v√† save
        if vuln.ref != expected_ref:
            vuln.ref = expected_ref
            vuln.save(update_fields=["ref"])  # ‚úÖ Ch·ªâ l∆∞u field ref
        vuln.api_count= AffectedURL.objects.filter(vulnerability=vuln).count()
        # vuln.affected_url_list = vuln.affected_url.split("\n") if vuln.affected_url else []  # T·∫°o danh s√°ch URL
        # vuln.api_count = len(vuln.affected_url_list)  # ƒê·∫øm s·ªë l∆∞·ª£ng API nh∆∞ng **kh√¥ng l∆∞u v√†o DB**

    export_logs = ExportLog.objects.filter(pentest_task=pentest_task).order_by('-export_time')
    # Chuy·ªÉn ƒë·ªïi export_time sang GMT+7
    bangkok = pytz.timezone('Asia/Bangkok')
    for log in export_logs:
        if log.export_time:
            log.export_time_vn = log.export_time.astimezone(bangkok).strftime('%d/%m/%Y %H:%M:%S')
        else:
            log.export_time_vn = None


    return render(request, "pentest_task/list_vulnerabilities.html", {
        "pentest_task": pentest_task,
        "vulnerabilities": vulnerabilities,
        "risk_summary": risk_summary,
        "risk_summary_api": risk_summary_api,
        "export_logs": export_logs,
    })


@login_required
@require_groups(['Pentester', 'Leader','Manager'])
def view_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)

    # Ki·ªÉm tra vulnerability thu·ªôc pentest_task
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    if vulnerability.pentest_task.id != pentest_task_id:
        raise PermissionDenied("Vulnerability kh√¥ng thu·ªôc v·ªÅ Pentest Task n√†y.")

    # L·∫•y danh s√°ch affected_urls c·ªßa vulnerability ƒë√≥
    affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)

    # Ki·ªÉm tra t·ª´ng AffectedURL (ph√≤ng khi c√≥ d·ªØ li·ªáu b·ªã nh·∫≠p nh·∫ßm DB)
    for url in affected_urls:
        if url.vulnerability_id != vulnerability.id:
            raise PermissionDenied("AffectedURL kh√¥ng kh·ªõp v·ªõi vulnerability.")


    # pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    # vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
    # # L·∫•y danh s√°ch affected_urls t·ª´ vulnerability
    # affected_urls = AffectedURL.objects.filter(vulnerability=vulnerability)
    return render(request, "pentest_task/view_vulnerability.html", {"form": vulnerability, "pentest_task": pentest_task, "affected_urls": affected_urls})


@login_required
@require_groups(['Pentester', 'Leader'])
def delete_vulnerability(request, pentest_task_id, vulnerability_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id, pentest_task=pentest_task)
    if request.method == "POST":
        messages.success(request, f"Vulnerability {vulnerability.name_vuln} has been deleted successfully.")
        logger.info(f"Vulnerability Deleted: {vulnerability}")  # Ghi log x√≥a task
        vulnerability.delete()
    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=pentest_task.id)


@login_required
@require_groups(['Pentester', 'Leader'])
def import_vulnerabilities(request):
    if request.method == "POST" and request.FILES.get("task_file"):
        file = request.FILES["task_file"]
        vulnerabilities = set()
        try:
            handle_uploaded_file(file)
            try:
                xls = pd.ExcelFile(file)
                # Sheet 1: VERIFY TASK
                vuln_df = pd.read_excel(xls, sheet_name="Vulnerability")
                for _, row in vuln_df.iterrows():
                    # pentest_task_name = safe_str(row.get("Task"))
                    
                    # if not pentest_task_name:
                    #     print("‚ö†Ô∏è B·ªè qua d√≤ng v√¨ kh√¥ng c√≥ pentest_task_name:", row.to_dict())
                    #     continue
                    ref=safe_str(row.get("REF")) #gi√° tr·ªã ref c·ªßa vulnerability
                    ref_prefix = "-".join(ref.split("-")[:-1]) # L·∫•y ph·∫ßn tr∆∞·ªõc d·∫•u "-" ƒë·ªÉ l·∫•y gi√° tr·ªã ref c·ªßa pentest_task
                    ref_prefix = safe_str(ref_prefix)  
                    name_vuln_row = safe_str(row.get("Issue Description "))
                    
                    try:
                        pentest_task = PentestTask.objects.get(ref=ref_prefix)
                        if pentest_task:
                            print(f"Found pentest_task: {pentest_task}")
                            messages.success(request, f"ƒê√£ t√¨m th·∫•y PentestTask v·ªõi ref: {pentest_task.ref}")
                            # messages.warning(request, f"ƒê√£ t√¨m th·∫•y PentestTask v·ªõi ref: {ref_prefix}")
                        else:
                            print("No pentest_task found.")
                            messages.error(request, f"Kh√¥ng t√¨m th·∫•y PentestTask v·ªõi ref: {pentest_task.ref}")
                    except PentestTask.DoesNotExist:
                        messages.warning(request, f"Kh√¥ng t√¨m th·∫•y PentestTask v·ªõi ref: {ref_prefix}")
                        continue

                    # ‚úÖ B·ªè qua n·∫øu Vulnerability ƒë√£ t·ªìn t·∫°i v·ªõi pentest_task v√† name_vuln
                    if Vulnerability.objects.filter(pentest_task=pentest_task, name_vuln=name_vuln_row).exists():
                        print(f"‚ö†Ô∏è Vulnerability '{name_vuln_row}' ƒë√£ t·ªìn t·∫°i cho task '{ref_prefix}', b·ªè qua.")
                        continue

                    Vulnerability.objects.create(
                        pentest_task=pentest_task,
                        ref=ref,
                        name_vuln=safe_str(row.get("Issue Description ")),
                        risk_rating=safe_str(row.get("Risk")),
                        notify_date=safe_date(request,row.get("Notify")),
                        status=safe_str(row.get("Status")),
                    )
           
                messages.success(request, "Vulnerability imported successfully")
            except Exception as e:
                messages.error(request, f"‚ùå Error in Vuln: {e}, row: {row.to_dict()}")
        except ValidationError as e:
            return HttpResponseBadRequest(str(e))   
        return redirect("pentest_task:list_pentest_tasks")


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_all_vulnerabilities(request):
    vulnerabilities = Vulnerability.objects.select_related("pentest_task").filter(
        name_vuln__isnull=False
    ).exclude(name_vuln="")

    total_count = vulnerabilities.count()
    open_count = vulnerabilities.filter(status="Open").count()
    high_risk_count = vulnerabilities.filter(risk_rating="High").count()

    return render(request, "pentest_task/list_all_vulnerabilities.html", {
        "vulnerabilities": vulnerabilities,
        "total_count": total_count,
        "open_count": open_count,
        "high_risk_count": high_risk_count,
    })
    

def convert_text(text):
    evidence_parts = []
    # html_content = markdown.markdown(text)
    html_content = markdown.markdown(
        text,
        extensions=["fenced_code", "codehilite"]
    )
    soup = BeautifulSoup(html_content, "html.parser")
    image_pattern = re.compile(r'!\[.*?\]\(data:image/.*?;base64,(.*?)\)', re.DOTALL)
    for element in soup.children:
        rt = RichText() 
        rt_code = RichText()
        rt_precode = RichText()
        rt_list = RichText()
        
        if element.name in ["h1", "h2", "h3"]:
            rt.add("\n")
            rt.add(element.text.strip(), bold=True,italic=True, size=37)
            rt.add("\n")
            evidence_parts.append({"type": "text", "content": rt})
            
        elif element.name == "blockquote":
            quote_text = element.get_text(strip=True)
            formatted = "\n> " + quote_text.replace("\n", "\n> ") + "\n"
            rt.add(formatted, italic=True, color="#555555")  
            evidence_parts.append({"type": "text", "content": rt})
        # Handle horizontal rule
        elif element.name == "hr":
            rt.add("-" * 30)
            evidence_parts.append({"type": "text", "content": rt})
           
        elif element.name == "p":
            for child in element.children:
                name = getattr(child, "name", None)
                if name == "strong":
                    rt.add(child.text, bold=True)
                    
                elif name == "em":
                    rt.add(child.text, italic=True)
                    
                elif name in ["h1", "h2", "h3"]:
                    rt.add(element.text.upper(), bold=True,size=23)
                    
                elif name == "code":
                    rt_code.add(child.text.strip(), italic=True, font="Consolas", color="#8B0000")
                    
                elif name is None:
                    rt.add(str(child))
                else:
                    rt.add(str(child))
                    
            evidence_parts.append({"type": "text", "content": rt})
            evidence_parts.append({"type": "code", "content": rt_code})
       
        elif element.name == "pre":
            code = element.find("code")
            code_text = code.get_text() if code else element.get_text()
            rt_precode.add(code_text.strip(), font="Consolas", size=20, color="#555555")
            evidence_parts.append({"type": "precode", "content": rt_precode})

        # list
        elif element.name == "ul":
            list_items = element.find_all("li", recursive=False)
            if list_items:
                rt = RichText()
                for li in list_items:
                    rt.add("‚Ä¢ ", bold=True)
                    rt.add(li.get_text(strip=True))
                    rt.add("\n")
                evidence_parts.append({"type": "text", "content": rt})
        # number list
        elif element.name == "ol":
            list_items = element.find_all("li", recursive=False)
            if list_items:
                for idx, li in enumerate(list_items, start=1):
                    rt = RichText()
                    rt.add(f"{idx}. ", bold=True)
                    rt.add(li.get_text(strip=True),bold=True)
                    rt.add("\n")
                    evidence_parts.append({"type": "text", "content": rt})

        # ==== FALLBACK ====
        else:
            rt.add(element.get_text())
            evidence_parts.append({"type": "text", "content": rt})

    return evidence_parts


def parse_evidence(evidence_md, doc):
    parts = []
    # B·∫Øt c·∫£ alt_text (caption) v√† image_data
    image_pattern = re.compile(r"!\[(.*?)\]\(data:image/.*?;base64,(.*?)\)")
    pos = 0
    rt = RichText()

    for match in image_pattern.finditer(evidence_md):
        start, end = match.span()

        # Ph·∫ßn text tr∆∞·ªõc ·∫£nh
        if start > pos:
            text = evidence_md[pos:start].strip()
            if text:
                parts.extend(convert_text(text))

        # L·∫•y caption v√† ·∫£nh
        alt_text = match.group(1)
        image_data = match.group(2)
        image_bytes = base64.b64decode(image_data)
        image_stream = BytesIO(image_bytes)
        image = InlineImage(doc, image_stream, width=Mm(130))
        parts.append({'type': 'image', 'content': image})

        # Caption d∆∞·ªõi ·∫£nh
        caption_rt = RichText()
        caption_rt.add(alt_text.strip(), italic=True, color="#666666")
        parts.append({'type': 'caption', 'content': caption_rt})

        pos = end

    # Ph·∫ßn c√≤n l·∫°i sau ·∫£nh cu·ªëi
    if pos < len(evidence_md):
        remaining_text = evidence_md[pos:].strip()
        if remaining_text:
            parts.extend(convert_text(remaining_text))

    return parts


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_pentest_report(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    appsec_task = pentest_task.appsec_task

    if not pentest_task.ref:
        messages.error(request, "‚ö†Ô∏èProvide unique REF and create report pentest again")
        return redirect("pentest_task:list_vulnerabilities", pentest_task_id=pentest_task.id)  # ho·∫∑c thay b·∫±ng trang ph√π h·ª£p

    # L·∫•y danh s√°ch vulnerabilities, s·∫Øp x·∫øp theo risk_score (cao -> th·∫•p)
    vulnerabilities = pentest_task.vulnerabilities.all().order_by('-risk_score')
    risk_summary,_ = risk_summary_data(pentest_task_id)
    
    # Load file Word t·ª´ template
    template = ReportConfig.get_current_template()
    if not template:
        raise Exception("Ch∆∞a c·∫•u h√¨nh template b√°o c√°o.")
    doc = DocxTemplate(template.file.path)

    # ki·ªÉm tra n·∫øu vuln.notify_date is None th√¨ g√°n ng√†y export l√† notify_date


    # template_path = os.path.join(settings.BASE_DIR, "templates/report", "pentest_template.docx")
    # doc = DocxTemplate(template_path)
    
    #T·∫°o danh s√°ch Ref ID theo th·ª© t·ª± risk_score
    for idx, vuln in enumerate(vulnerabilities, start=1):
        vuln.ref = f"{pentest_task.ref}-{str(idx).zfill(2)}"
        if not vuln.notify_date:
            vuln.notify_date = timezone.now().date()
        vuln.save()  # C·∫≠p nh·∫≠t ref v√†o DB
    
    # X·ª≠ l√Ω d·ªØ li·ªáu th·ªùi gian & ki·ªÉm tra `None`
    def safe_date(date_value, format_str="%d/%m/%Y"):
        return date_value.strftime(format_str) if date_value else ""

    # Chuy·ªÉn ƒë·ªïi danh s√°ch API t·ª´ tr∆∞·ªùng `scope`
    scope_list = pentest_task.scope.splitlines() if pentest_task.scope else []
    scope_table = [{"No": idx + 1, "API": api} for idx, api in enumerate(scope_list)]

    # ƒê·ªãnh nghƒ©a m√†u ch·ªØ cho t·ª´ng m·ª©c ƒë·ªô risk rating (d√πng HEX m√†u Word)
    risk_text_colors = {
        "Critical": "8B0000",  # ƒê·ªè ƒë·∫≠m
        "High": "FF0000",      # ƒê·ªè
        "Medium": "FFA500",    # Cam
        "Low": "008000",       # Xanh l√° ƒë·∫≠m
        "Recommend": "32CD32"  # Xanh l√° nh·∫°t
    }
    # s·∫Øp x·∫øp vuln theo risk_score gi·∫£m d·∫ßn    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    placeholder_vulns = []
    for vuln in vulnerabilities:
        color = risk_text_colors.get(vuln.risk_rating, "000000")  # M·∫∑c ƒë·ªãnh l√† ƒêen (000000)
        color_likelihood_rate = risk_text_colors.get(vuln.likelihood_rate, "000000")  # M·∫∑c ƒë·ªãnh l√† ƒêen (000000)
        color_impact_rate = risk_text_colors.get(vuln.impact_rate, "000000")  # M·∫∑c ƒë·ªãnh l√† ƒêen (000000)

        # L·∫•y danh s√°ch affected_url t·ª´ model m·ªõi
        affected_url_qs = AffectedURL.objects.filter(vulnerability=vuln)
        affected_url_table = [
            {
                "No": idx + 1,
                "Function": url.function or "",
                "API": url.vuln_api or "",
                "Params": url.params or "",
            }
            for idx, url in enumerate(affected_url_qs)
        ]


        # Format XML ƒë·ªÉ Word hi·ªÉu m√†u ch·ªØ
        risk_rating_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>'
        risk_score_xml = f'<w:r><w:rPr><w:color w:val="{color}"/></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>'
        risk_likelihood_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_likelihood_rate}"/></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>'
        risk_impact_rate_xml = f'<w:r><w:rPr><w:color w:val="{color_impact_rate}"/></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>'
        placeholder_vulns.append({
                "ref": vuln.ref,
                "name_vuln": vuln.name_vuln,
                "description":vuln.description,
                "risk_score": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_score}</w:t></w:r>',
                "risk_vector": vuln.risk_vector,
                "risk_rating": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.risk_rating, "000000")}" /></w:rPr><w:t>{vuln.risk_rating}</w:t></w:r>',
                "likelihood_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.likelihood_rate, "000000")}" /></w:rPr><w:t>{vuln.likelihood_rate}</w:t></w:r>',
                "impact_rate": f'<w:r><w:rPr><w:color w:val="{risk_text_colors.get(vuln.impact_rate, "000000")}" /></w:rPr><w:t>{vuln.impact_rate}</w:t></w:r>',
                # "likelihood": vuln.likelihood,
                "risk_av": vuln.risk_av,
                "risk_ac": vuln.risk_ac,
                "risk_pr": vuln.risk_pr,
                "risk_ui": vuln.risk_ui,
                "impact": vuln.impact,
                "evidence_parts": parse_evidence(vuln.evidence, doc),
                "affected_url_table": affected_url_table,
                # "api_count": len(vuln.affected_url.split("\n")) if vuln.affected_url else 0,  # ƒê·∫øm s·ªë API
                "recommendation": vuln.recommendation,
                "reference": vuln.reference,
                "status": vuln.status,
            })
   

    placeholders = {
        "task_name": str(pentest_task.name) if pentest_task.name else "",
        "scope": scope_table,
        "today": datetime.today().strftime("%B %d %Y"),  # "March 06 2024"
        "component": str(pentest_task.component) if pentest_task.component else "",
        "start_date": safe_date(pentest_task.start_date, "%B %d %Y"),
        "start_month": safe_date(pentest_task.start_date, "%B"),
        "start_year": str(pentest_task.start_date.year) if pentest_task.start_date else "",
        "end_date": safe_date(pentest_task.end_date, "%B %d %Y"),
        "total_vulnerabilities": str(sum(risk_summary.values())),
        "count_critical": str(risk_summary.get("Critical", 0)),
        "count_high": str(risk_summary.get("High", 0)),
        "count_medium": str(risk_summary.get("Medium", 0)),
        "count_low": str(risk_summary.get("Low", 0)),
        "count_recommend": str(risk_summary.get("Recommend", 0)),
        "environment_prod": str(appsec_task.environment_prod) if appsec_task.environment_prod else "",
        "environment_test": str(pentest_task.environment_test) if pentest_task.environment_test else "",
        "vulnerabilities": placeholder_vulns

    }
        # Truy·ªÅn v√†o word:    Task Name: {{ task_name }}
        # Component: {{ component }}
        # Start Date: {{ start_date }}
        # {% for vuln in vulnerabilities %} {{vuln.name_vuln}} {% endfor %} 

    # ƒêi·ªÅn d·ªØ li·ªáu v√†o template
    doc.render(placeholders)
    # ‚úÖ Ghi log export report
    ExportLog.objects.create(
        pentest_task=pentest_task,
        user=request.user
    )


    # Xu·∫•t file Word v·ªõi d·ªØ li·ªáu ƒë√£ thay th·∫ø
    response = HttpResponse(content_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
    response["Content-Disposition"] = f'attachment; filename="Pentest_Report_{pentest_task.name}.docx"'
    doc.save(response)

    return response


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def export_details_vulnerability_excel(request, pentest_task_id):
    pentest_task = get_object_or_404(PentestTask, id=pentest_task_id)
    vulnerabilities = Vulnerability.objects.filter(pentest_task_id=pentest_task_id).prefetch_related('affected_urls')
    # s·∫Øp x·∫øp vuln theo risk_score gi·∫£m d·∫ßn    
    vulnerabilities = sorted(
        vulnerabilities,
        key=lambda v: float(v.risk_score) if v.risk_score else 0,
        reverse=True
    )
    affected_data = []
    for vuln in vulnerabilities:
        for au in vuln.affected_urls.all():
            affected_data.append({
                "Vuln Name": vuln.name_vuln or "",
                "Ref ID": vuln.ref or "",
                "Risk Rating":vuln.risk_rating or "",
                "Function Name": au.function or "",
                "Vuln API": au.vuln_api or "",
                "Request": au.request or "",
                "Response": au.response or "",
                "Params": au.params or "",
                "Note": au.note or "",
                "POC": au.poc or "",  # POC l√† markdown text (c√≥ th·ªÉ ch·ª©a ·∫£nh base64)
            })

    df = pd.DataFrame(affected_data)

    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name="Affected URLs", index=False)
        workbook  = writer.book
        worksheet = writer.sheets["Affected URLs"]

        # ƒê·ªãnh d·∫°ng k√≠ch th∆∞·ªõc c·ªôt v√† d√≤ng
        worksheet.set_column('A:H', 70)  # TƒÉng ƒë·ªô r·ªông c√°c c·ªôt
        for row in range(1, len(df) + 1):
            worksheet.set_row(row, 170)  # Chi·ªÅu cao d√≤ng c·ªë ƒë·ªãnh

        # Duy·ªát l·∫°i t·ª´ng d√≤ng ƒë·ªÉ x·ª≠ l√Ω POC
        image_pattern = re.compile(r"!\[.*?\]\(data:image/.*?;base64,(.*?)\)")

        for i, poc_md in enumerate(df["POC"]):
            cell_row = i + 1
            text_part = image_pattern.split(poc_md)[0].strip()

            # Ghi ph·∫ßn text c·ªßa POC (n·∫øu c√≥)
            if text_part:
                worksheet.write(cell_row, len(df.columns)-1, text_part)

            # Ch√®n ·∫£nh (n·∫øu c√≥)
            for match in image_pattern.finditer(poc_md):
                image_data = match.group(1)
                try:
                    image_bytes = base64.b64decode(image_data)
                    image_stream = BytesIO(image_bytes)

                    # Ki·ªÉm tra h·ª£p l·ªá
                    img = Image.open(image_stream)
                    img.verify()
                    image_stream.seek(0)

                    worksheet.insert_image(
                        cell_row,
                        len(df.columns)-1,
                        "image.png",
                        {
                            'image_data': image_stream,
                            'x_scale': 1,
                            'y_scale': 1,
                            'positioning': 1,
                        }
                    )
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói ch√®n ·∫£nh d√≤ng {cell_row}: {e}")

    output.seek(0)
    filename = f"details_vuln_of_{pentest_task.name}.xlsx"
    response = HttpResponse(output, content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = f'attachment; filename={filename}'

    return response


@login_required
@require_groups(['Pentester', 'Leader'])
@csrf_exempt
def martor_upload_image(request):
    try:
        print("üü¢ ƒê√£ g·ªçi martor_upload_image")
        print("Upload method:", PETEREPORT_MARKDOWN.get("martor_upload_method"))
        print("Upload path:", MARTOR_UPLOAD_PATH)

        if request.method == 'POST' and request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            if 'markdown-image-upload' in request.FILES:
                image = request.FILES['markdown-image-upload']
                print("üì∑ ƒê√£ nh·∫≠n file:", image.name, image.content_type)

                # Ki·ªÉm tra ƒë·ªãnh d·∫°ng
                image_types = [
                    'image/png', 'image/jpg', 'image/jpeg', 'image/pjpeg', 'image/gif'
                ]
                if image.content_type not in image_types:
                    return JsonResponse({'status': 405, 'error': 'Bad image format.'}, status=405)

                if image.size > MAX_IMAGE_UPLOAD_SIZE:
                    return JsonResponse({
                        'status': 405,
                        'error': f'Maximum image file is {MAX_IMAGE_UPLOAD_SIZE / (1024 * 1024)} MB.'
                    }, status=405)

                if PETEREPORT_MARKDOWN['martor_upload_method'] == 'BASE64':
                    image_content_base64 = base64.b64encode(image.read()).decode('utf-8')
                    image_content_base64_final = f'data:{image.content_type};base64,{image_content_base64}'
                    return JsonResponse({
                        'status': 200,
                        'link': image_content_base64_final,
                        'name': image.name
                    })

                elif PETEREPORT_MARKDOWN['martor_upload_method'] == 'MEDIA':
                    today = datetime.date.today().strftime('%Y/%m/%d/')
                    img_uuid = f"{uuid.uuid4().hex[:32]}-{image.name.replace(' ', '-')}"
                    tmp_path = os.path.join(MARTOR_UPLOAD_PATH, today, img_uuid)

                    print("üìÅ L∆∞u file v√†o:", tmp_path)

                    def_path = default_storage.save(tmp_path, ContentFile(image.read()))
                    img_url = os.path.join(MARTOR_MEDIA_URL, def_path)

                    return JsonResponse({
                        'status': 200,
                        'link': img_url,
                        'name': image.name
                    })

        return JsonResponse({'status': 400, 'error': 'Invalid request!'}, status=400)

    except Exception as e:
        print("‚ùå Exception x·∫£y ra khi upload:", str(e))
        return JsonResponse({'error': str(e)}, status=500)


#ch·ª©c nƒÉng t·∫°o template
@login_required
@require_groups(['Pentester', 'Leader'])
def save_to_template(request, vuln_id):
    vuln = get_object_or_404(Vulnerability, id=vuln_id)
    
    # Ki·ªÉm tra xem template c√≥ t·ªìn t·∫°i ch∆∞a
    template, created = VulnTemplate.objects.update_or_create(
        name_vuln=vuln.name_vuln,  # T·∫°o m·ªõi ho·∫∑c c·∫≠p nh·∫≠t n·∫øu tr√πng t√™n
        defaults={
            'risk_score': vuln.risk_score,
            'risk_vector': vuln.risk_vector,
            'risk_rating': vuln.risk_rating,
            'description': vuln.description,
            'likelihood_rate': vuln.likelihood_rate,
            'risk_av': vuln.risk_av,
            'risk_ac': vuln.risk_ac,
            'risk_pr': vuln.risk_pr,
            'risk_ui': vuln.risk_ui,
            'impact_rate': vuln.impact_rate,
            'impact': vuln.impact,
            'recommendation': vuln.recommendation,
            'reference': vuln.reference,
        }
    )

    if created:
        messages.success(request, f"Template '{vuln.name_vuln}' was updated.")
    else:
        messages.info(request, f"Template '{vuln.name_vuln}' was updated.")

    return redirect('pentest_task:list_vulnerabilities', pentest_task_id=vuln.pentest_task_id)


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def list_vuln_templates(request):
    templates = VulnTemplate.objects.all()
    return render(request, 'pentest_task/list_vuln_templates.html', {'vulnerabilities': templates})


@login_required
@require_groups(['Pentester', 'Leader', 'Manager'])
def view_vuln_template(request, vuln_template_id):
    vuln_template = get_object_or_404(VulnTemplate, id=vuln_template_id)
    return render(request, 'pentest_task/view_vuln_template.html', {'form': vuln_template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_create(request):
    form = VulnTemplateForm(request.POST or None)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_edit(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    form = VulnTemplateForm(request.POST or None, instance=template)
    if form.is_valid():
        form.save()
        return redirect('pentest_task:list_vuln_templates')
    return render(request, 'pentest_task/vuln_template_create.html', {'form': form, 'template': template})


@login_required
@require_groups(['Pentester', 'Leader'])
def vuln_template_delete(request, pk):
    template = get_object_or_404(VulnTemplate, pk=pk)
    if request.method == "POST":
        template.delete()
    return redirect('pentest_task:list_vuln_templates')  # Quay l·∫°i danh s√°ch ngay


@login_required
@require_groups(['Pentester', 'Leader'])
def my_task_view(request):
    my_tasks = PentestTask.objects.filter(PIC_ISM=request.user)
    return render(request, 'pentest_task/my_tasks.html', {'tasks': my_tasks})


@login_required
@require_groups(['Pentester', 'Leader'])
def list_templates(request):
    templates = TemplateReport.objects.all()
    current_config = ReportConfig.objects.first()
    current_template_id = current_config.current_template.id if current_config and current_config.current_template else None

    if request.method == "POST":
        selected_id = request.POST.get("selected_template")
        selected_template = TemplateReport.objects.get(id=selected_id)

        if not current_config:
            current_config = ReportConfig(current_template=selected_template)
        else:
            current_config.current_template = selected_template

        current_config.save()
        return redirect("pentest_task:list_templates")

    return render(request, "pentest_task/report_template/list_templates.html", {
        "templates": templates,
        "current_template_id": current_template_id,
    })


@login_required
@require_groups(['Pentester', 'Leader'])
def edit_template(request, pk):
    template = get_object_or_404(TemplateReport, pk=pk)
    if request.method == "POST":
        form = TemplateReportForm(request.POST, request.FILES, instance=template)
        if form.is_valid():
            file = request.FILES["file"]
            try:
                handle_uploaded_file(file)
        
                form.save()
                messages.success(request, "Update report template successfully.")
            except ValidationError as e:
                return HttpResponseBadRequest(str(e))
            return redirect("pentest_task:list_templates")
    else:
        form = TemplateReportForm(instance=template)
    return render(request, "pentest_task/report_template/edit_template.html", {"form": form, "template": template})


@login_required
@require_groups(['Pentester', 'Leader'])
def delete_template(request, pk):
    template = get_object_or_404(TemplateReport, pk=pk)
    if request.method == "POST":
        template.delete()
        messages.success(request, "Deleted report template successfully.")
        return redirect("pentest_task:list_templates")
    return render(request, "pentest/report_template/delete_template.html", {"template": template})


@login_required
@require_groups(['Pentester', 'Leader'])
def upload_template(request):
    if request.method == "POST":
        form = TemplateReportForm(request.POST, request.FILES)
        if form.is_valid():
            file = request.FILES["file"]
            try:
                handle_uploaded_file(file)
            
                form.save()
            except ValidationError as e:
                return HttpResponseBadRequest(str(e))
            return redirect("pentest_task:list_templates")
    else:
        form = TemplateReportForm()

    return render(request, "pentest_task/report_template/upload_template.html", {
        "form": form
    })


def select_template(request, template_id):
    template = get_object_or_404(TemplateReport, id=template_id)
    config = ReportConfig.objects.first()
    if not config:
        config = ReportConfig.objects.create(current_template=template)
    else:
        config.current_template = template
        config.save()
    return redirect("pentest_task:list_templates")  # ho·∫∑c t√™n URL c·ªßa trang danh s√°ch template


def custom_404_view(request, exception):
    return render(request, "404.html", status=404)

